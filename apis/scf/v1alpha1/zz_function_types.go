/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CfsConfigObservation struct {
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	MountSubnetID *string `json:"mountSubnetId,omitempty" tf:"mount_subnet_id,omitempty"`

	MountVPCID *string `json:"mountVpcId,omitempty" tf:"mount_vpc_id,omitempty"`
}

type CfsConfigParameters struct {

	// File system instance ID.
	// +kubebuilder:validation:Required
	CfsID *string `json:"cfsId" tf:"cfs_id,omitempty"`

	// Local mount directory.
	// +kubebuilder:validation:Required
	LocalMountDir *string `json:"localMountDir" tf:"local_mount_dir,omitempty"`

	// File system mount instance ID.
	// +kubebuilder:validation:Required
	MountInsID *string `json:"mountInsId" tf:"mount_ins_id,omitempty"`

	// Remote mount directory.
	// +kubebuilder:validation:Required
	RemoteMountDir *string `json:"remoteMountDir" tf:"remote_mount_dir,omitempty"`

	// ID of user group.
	// +kubebuilder:validation:Required
	UserGroupID *string `json:"userGroupId" tf:"user_group_id,omitempty"`

	// ID of user.
	// +kubebuilder:validation:Required
	UserID *string `json:"userId" tf:"user_id,omitempty"`
}

type FunctionObservation struct {
	CfsConfig []CfsConfigObservation `json:"cfsConfig,omitempty" tf:"cfs_config,omitempty"`

	CodeError *string `json:"codeError,omitempty" tf:"code_error,omitempty"`

	CodeResult *string `json:"codeResult,omitempty" tf:"code_result,omitempty"`

	CodeSize *float64 `json:"codeSize,omitempty" tf:"code_size,omitempty"`

	EIPFixed *bool `json:"eipFixed,omitempty" tf:"eip_fixed,omitempty"`

	Eips []*string `json:"eips,omitempty" tf:"eips,omitempty"`

	ErrNo *float64 `json:"errNo,omitempty" tf:"err_no,omitempty"`

	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InstallDependency *bool `json:"installDependency,omitempty" tf:"install_dependency,omitempty"`

	ModifyTime *string `json:"modifyTime,omitempty" tf:"modify_time,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	StatusDesc *string `json:"statusDesc,omitempty" tf:"status_desc,omitempty"`

	TriggerInfo []TriggerInfoObservation `json:"triggerInfo,omitempty" tf:"trigger_info,omitempty"`

	Vip *string `json:"vip,omitempty" tf:"vip,omitempty"`
}

type FunctionParameters struct {

	// Whether SCF function asynchronous attribute is enabled. `TRUE` is open, `FALSE` is close.
	// +kubebuilder:validation:Optional
	AsyncRunEnable *string `json:"asyncRunEnable,omitempty" tf:"async_run_enable,omitempty"`

	// List of CFS configurations.
	// +kubebuilder:validation:Optional
	CfsConfig []CfsConfigParameters `json:"cfsConfig,omitempty" tf:"cfs_config,omitempty"`

	// cls logset id of the SCF function.
	// +kubebuilder:validation:Optional
	ClsLogsetID *string `json:"clsLogsetId,omitempty" tf:"cls_logset_id,omitempty"`

	// cls topic id of the SCF function.
	// +kubebuilder:validation:Optional
	ClsTopicID *string `json:"clsTopicId,omitempty" tf:"cls_topic_id,omitempty"`

	// Cos bucket name of the SCF function, such as `cos-1234567890`, conflict with `zip_file`.
	// +kubebuilder:validation:Optional
	CosBucketName *string `json:"cosBucketName,omitempty" tf:"cos_bucket_name,omitempty"`

	// Cos bucket region of the SCF function, conflict with `zip_file`.
	// +kubebuilder:validation:Optional
	CosBucketRegion *string `json:"cosBucketRegion,omitempty" tf:"cos_bucket_region,omitempty"`

	// Cos object name of the SCF function, should have suffix `.zip` or `.jar`, conflict with `zip_file`.
	// +kubebuilder:validation:Optional
	CosObjectName *string `json:"cosObjectName,omitempty" tf:"cos_object_name,omitempty"`

	// Description of the SCF function. Description supports English letters, numbers, spaces, commas, newlines, periods and Chinese, the maximum length is 1000.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Indicates whether EIP config set to `ENABLE` when `enable_public_net` was true. Default `false`.
	// +kubebuilder:validation:Optional
	EnableEIPConfig *bool `json:"enableEipConfig,omitempty" tf:"enable_eip_config,omitempty"`

	// Indicates whether public net config enabled. Default `false`. NOTE: only `vpc_id` specified can disable public net config.
	// +kubebuilder:validation:Optional
	EnablePublicNet *bool `json:"enablePublicNet,omitempty" tf:"enable_public_net,omitempty"`

	// Environment of the SCF function.
	// +kubebuilder:validation:Optional
	Environment map[string]*string `json:"environment,omitempty" tf:"environment,omitempty"`

	// Function type. The default value is Event. Enter Event if you need to create a trigger function. Enter HTTP if you need to create an HTTP function service.
	// +kubebuilder:validation:Optional
	FuncType *string `json:"funcType,omitempty" tf:"func_type,omitempty"`

	// Handler of the SCF function. The format of name is `<filename>.<method_name>`, and it supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
	// +kubebuilder:validation:Optional
	Handler *string `json:"handler,omitempty" tf:"handler,omitempty"`

	// Image of the SCF function, conflict with ``.
	// +kubebuilder:validation:Optional
	ImageConfig []ImageConfigParameters `json:"imageConfig,omitempty" tf:"image_config,omitempty"`

	// Enable L5 for SCF function, default is `false`.
	// +kubebuilder:validation:Optional
	L5Enable *bool `json:"l5Enable,omitempty" tf:"l5_enable,omitempty"`

	// The list of association layers.
	// +kubebuilder:validation:Optional
	Layers []LayersParameters `json:"layers,omitempty" tf:"layers,omitempty"`

	// Memory size of the SCF function, unit is MB. The default is `128`MB. The ladder is 128M.
	// +kubebuilder:validation:Optional
	MemSize *float64 `json:"memSize,omitempty" tf:"mem_size,omitempty"`

	// Name of the SCF function. Name supports 26 English letters, numbers, connectors, and underscores, it should start with a letter. The last character cannot be `-` or `_`. Available length is 2-60.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Namespace of the SCF function, default is `default`.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Role of the SCF function.
	// +kubebuilder:validation:Optional
	Role *string `json:"role,omitempty" tf:"role,omitempty"`

	// Runtime of the SCF function, only supports `Python2.7`, `Python3.6`, `Nodejs6.10`, `Nodejs8.9`, `Nodejs10.15`, `PHP5`, `PHP7`, `Golang1`, and `Java8`.
	// +kubebuilder:validation:Optional
	Runtime *string `json:"runtime,omitempty" tf:"runtime,omitempty"`

	// Subnet ID of the SCF function.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Tags of the SCF function.
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Timeout of the SCF function, unit is second. Default `3`. Available value is 1-900.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Trigger list of the SCF function, note that if you modify the trigger list, all existing triggers will be deleted, and then create triggers in the new list. Each element contains the following attributes:
	// +kubebuilder:validation:Optional
	Triggers []TriggersParameters `json:"triggers,omitempty" tf:"triggers,omitempty"`

	// VPC ID of the SCF function.
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`

	// Zip file of the SCF function, conflict with `cos_bucket_name`, `cos_object_name`, `cos_bucket_region`.
	// +kubebuilder:validation:Optional
	ZipFile *string `json:"zipFile,omitempty" tf:"zip_file,omitempty"`
}

type ImageConfigObservation struct {
}

type ImageConfigParameters struct {

	// the parameters of command.
	// +kubebuilder:validation:Optional
	Args *string `json:"args,omitempty" tf:"args,omitempty"`

	// The command of entrypoint.
	// +kubebuilder:validation:Optional
	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	// The entrypoint of app.
	// +kubebuilder:validation:Optional
	EntryPoint *string `json:"entryPoint,omitempty" tf:"entry_point,omitempty"`

	// The image type. personal or enterprise.
	// +kubebuilder:validation:Required
	ImageType *string `json:"imageType" tf:"image_type,omitempty"`

	// The uri of image.
	// +kubebuilder:validation:Required
	ImageURI *string `json:"imageUri" tf:"image_uri,omitempty"`

	// The registry id of TCR. When image type is enterprise, it must be set.
	// +kubebuilder:validation:Optional
	RegistryID *string `json:"registryId,omitempty" tf:"registry_id,omitempty"`
}

type LayersObservation struct {
}

type LayersParameters struct {

	// The name of Layer.
	// +kubebuilder:validation:Required
	LayerName *string `json:"layerName" tf:"layer_name,omitempty"`

	// The version of layer.
	// +kubebuilder:validation:Required
	LayerVersion *float64 `json:"layerVersion" tf:"layer_version,omitempty"`
}

type TriggerInfoObservation struct {
	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	CustomArgument *string `json:"customArgument,omitempty" tf:"custom_argument,omitempty"`

	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	ModifyTime *string `json:"modifyTime,omitempty" tf:"modify_time,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	TriggerDesc *string `json:"triggerDesc,omitempty" tf:"trigger_desc,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type TriggerInfoParameters struct {
}

type TriggersObservation struct {
}

type TriggersParameters struct {

	// Region of cos bucket. if `type` is `cos`, `cos_region` is required.
	// +kubebuilder:validation:Optional
	CosRegion *string `json:"cosRegion,omitempty" tf:"cos_region,omitempty"`

	// Name of the SCF function trigger, if `type` is `ckafka`, the format of name must be `<ckafkaInstanceId>-<topicId>`; if `type` is `cos`, the name is cos bucket id, other In any case, it can be combined arbitrarily. It can only contain English letters, numbers, connectors and underscores. The maximum length is 100.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// TriggerDesc of the SCF function trigger, parameter format of `timer` is linux cron expression; parameter of `cos` type is json string `{"bucketUrl":"<name-appid>.cos.<region>.myqcloud.com","event":"cos:ObjectCreated:*","filter":{"Prefix":"","Suffix":""}}`, where `bucketUrl` is cos bucket (optional), `event` is the cos event trigger, `Prefix` is the corresponding file prefix filter condition, `Suffix` is the suffix filter condition, if not need filter condition can not pass; `cmq` type does not pass this parameter; `ckafka` type parameter format is json string `{"maxMsgNum":"1","offset":"latest"}`; `apigw` type parameter format is json string `{"api":{"authRequired":"FALSE","requestConfig":{"method":"ANY"},"isIntegratedResponse":"FALSE"},"service":{"serviceId":"service-dqzh68sg"},"release":{"environmentName":"test"}}`.
	// +kubebuilder:validation:Required
	TriggerDesc *string `json:"triggerDesc" tf:"trigger_desc,omitempty"`

	// Type of the SCF function trigger, support `cos`, `cmq`, `timer`, `ckafka`, `apigw`.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// FunctionSpec defines the desired state of Function
type FunctionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     FunctionParameters `json:"forProvider"`
}

// FunctionStatus defines the observed state of Function.
type FunctionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        FunctionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Function is the Schema for the Functions API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Function struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FunctionSpec   `json:"spec"`
	Status            FunctionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// FunctionList contains a list of Functions
type FunctionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Function `json:"items"`
}

// Repository type metadata.
var (
	Function_Kind             = "Function"
	Function_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Function_Kind}.String()
	Function_KindAPIVersion   = Function_Kind + "." + CRDGroupVersion.String()
	Function_GroupVersionKind = CRDGroupVersion.WithKind(Function_Kind)
)

func init() {
	SchemeBuilder.Register(&Function{}, &FunctionList{})
}
