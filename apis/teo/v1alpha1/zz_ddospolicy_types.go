/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ACLObservation struct {
}

type ACLParameters struct {

	// DDoS ACL rule configuration detail.
	// +kubebuilder:validation:Optional
	Acls []AclsParameters `json:"acls,omitempty" tf:"acls,omitempty"`

	// - `on`: Enable. `Acl` parameter is require.- `off`: Disable.
	// +kubebuilder:validation:Optional
	Switch *string `json:"switch,omitempty" tf:"switch,omitempty"`
}

type AclsObservation struct {
}

type AclsParameters struct {

	// Action to take. Valid values: `drop`, `transmit`, `forward`.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// End of the dest port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	DportEnd *float64 `json:"dportEnd,omitempty" tf:"dport_end,omitempty"`

	// Start of the dest port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	DportStart *float64 `json:"dportStart,omitempty" tf:"dport_start,omitempty"`

	// Valid values: `tcp`, `udp`, `all`.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// End of the source port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	SportEnd *float64 `json:"sportEnd,omitempty" tf:"sport_end,omitempty"`

	// Start of the source port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	SportStart *float64 `json:"sportStart,omitempty" tf:"sport_start,omitempty"`
}

type AllowBlockIpsObservation struct {
	UpdateTime *float64 `json:"updateTime,omitempty" tf:"update_time,omitempty"`
}

type AllowBlockIpsParameters struct {

	// Valid value format:- ip, for example 1.1.1.1- ip range, for example 1.1.1.2-1.1.1.3- network segment, for example 1.2.1.0/24- network segment range, for example 1.2.1.0/24-1.2.2.0/24.
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// Valid values: `block`, `allow`.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type AllowBlockObservation struct {
	AllowBlockIps []AllowBlockIpsObservation `json:"allowBlockIps,omitempty" tf:"allow_block_ips,omitempty"`
}

type AllowBlockParameters struct {

	// DDoS black-white list detail.
	// +kubebuilder:validation:Optional
	AllowBlockIps []AllowBlockIpsParameters `json:"allowBlockIps,omitempty" tf:"allow_block_ips,omitempty"`

	// - `on`: Enable. `AllowBlockIps` parameter is required.- `off`: Disable.
	// +kubebuilder:validation:Optional
	Switch *string `json:"switch,omitempty" tf:"switch,omitempty"`
}

type AntiPlyObservation struct {
}

type AntiPlyParameters struct {

	// Abnormal connections threshold. Valid value range: 0-4294967295.
	// +kubebuilder:validation:Required
	AbnormalConnectNum *float64 `json:"abnormalConnectNum" tf:"abnormal_connect_num,omitempty"`

	// Abnormal syn packet number threshold. Valid value range: 0-65535.
	// +kubebuilder:validation:Required
	AbnormalSynNum *float64 `json:"abnormalSynNum" tf:"abnormal_syn_num,omitempty"`

	// Abnormal syn packet ratio threshold. Valid value range: 0-100.
	// +kubebuilder:validation:Required
	AbnormalSynRatio *float64 `json:"abnormalSynRatio" tf:"abnormal_syn_ratio,omitempty"`

	// Connection timeout detection per second. Valid value range: 0-65535.
	// +kubebuilder:validation:Required
	ConnectTimeout *float64 `json:"connectTimeout" tf:"connect_timeout,omitempty"`

	// Limitation of connections to dest port. Valid value range: 0-4294967295.
	// +kubebuilder:validation:Required
	DestinationConnectLimit *float64 `json:"destinationConnectLimit" tf:"destination_connect_limit,omitempty"`

	// Limitation of new connection to dest port per second. Valid value range: 0-4294967295.
	// +kubebuilder:validation:Required
	DestinationCreateLimit *float64 `json:"destinationCreateLimit" tf:"destination_create_limit,omitempty"`

	// Block ICMP protocol. Valid values: `on`, `off`.
	// +kubebuilder:validation:Required
	DropIcmp *string `json:"dropIcmp" tf:"drop_icmp,omitempty"`

	// Block other protocols. Valid values: `on`, `off`.
	// +kubebuilder:validation:Required
	DropOther *string `json:"dropOther" tf:"drop_other,omitempty"`

	// Block TCP protocol. Valid values: `on`, `off`.
	// +kubebuilder:validation:Required
	DropTCP *string `json:"dropTcp" tf:"drop_tcp,omitempty"`

	// Block UDP protocol. Valid values: `on`, `off`.
	// +kubebuilder:validation:Required
	DropUDP *string `json:"dropUdp" tf:"drop_udp,omitempty"`

	// Empty connection protection switch. Valid values: `on`, `off`.
	// +kubebuilder:validation:Required
	EmptyConnectProtect *string `json:"emptyConnectProtect" tf:"empty_connect_protect,omitempty"`

	// Limitation of connections to origin site. Valid value range: 0-4294967295.
	// +kubebuilder:validation:Required
	SourceConnectLimit *float64 `json:"sourceConnectLimit" tf:"source_connect_limit,omitempty"`

	// Limitation of new connection to origin site per second. Valid value range: 0-4294967295.
	// +kubebuilder:validation:Required
	SourceCreateLimit *float64 `json:"sourceCreateLimit" tf:"source_create_limit,omitempty"`

	// UDP shard protection switch. Valid values: `on`, `off`.
	// +kubebuilder:validation:Optional
	UDPShard *string `json:"udpShard,omitempty" tf:"udp_shard,omitempty"`
}

type DDosPolicyObservation struct {
	DdosRule []DdosRuleObservation `json:"ddosRule,omitempty" tf:"ddos_rule,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type DDosPolicyParameters struct {

	// DDoS Configuration of the zone.
	// +kubebuilder:validation:Optional
	DdosRule []DdosRuleParameters `json:"ddosRule,omitempty" tf:"ddos_rule,omitempty"`

	// Policy ID.
	// +kubebuilder:validation:Required
	PolicyID *float64 `json:"policyId" tf:"policy_id,omitempty"`

	// Site ID.
	// +crossplane:generate:reference:type=Zone
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

type DdosRuleObservation struct {
	AllowBlock []AllowBlockObservation `json:"allowBlock,omitempty" tf:"allow_block,omitempty"`
}

type DdosRuleParameters struct {

	// DDoS ACL rule configuration.
	// +kubebuilder:validation:Optional
	ACL []ACLParameters `json:"acl,omitempty" tf:"acl,omitempty"`

	// DDoS black-white list.
	// +kubebuilder:validation:Optional
	AllowBlock []AllowBlockParameters `json:"allowBlock,omitempty" tf:"allow_block,omitempty"`

	// DDoS protocol and connection protection.
	// +kubebuilder:validation:Optional
	AntiPly []AntiPlyParameters `json:"antiPly,omitempty" tf:"anti_ply,omitempty"`

	// DDoS Protection by Geo Info.
	// +kubebuilder:validation:Optional
	GeoIP []GeoIPParameters `json:"geoIp,omitempty" tf:"geo_ip,omitempty"`

	// DDoS feature filtering configuration.
	// +kubebuilder:validation:Optional
	PacketFilter []PacketFilterParameters `json:"packetFilter,omitempty" tf:"packet_filter,omitempty"`

	// DDoS access origin site speed limit configuration.
	// +kubebuilder:validation:Optional
	SpeedLimit []SpeedLimitParameters `json:"speedLimit,omitempty" tf:"speed_limit,omitempty"`

	// DDoS protection level.
	// +kubebuilder:validation:Optional
	StatusInfo []StatusInfoParameters `json:"statusInfo,omitempty" tf:"status_info,omitempty"`

	// DDoS protection switch. Valid values:- `on`: Enable.- `off`: Disable.
	// +kubebuilder:validation:Optional
	Switch *string `json:"switch,omitempty" tf:"switch,omitempty"`
}

type GeoIPObservation struct {
}

type GeoIPParameters struct {

	// Region ID. See details in data source `security_policy_regions`.
	// +kubebuilder:validation:Optional
	RegionIds []*float64 `json:"regionIds,omitempty" tf:"region_ids,omitempty"`

	// - `on`: Enable.- `off`: Disable.
	// +kubebuilder:validation:Optional
	Switch *string `json:"switch,omitempty" tf:"switch,omitempty"`
}

type PacketFilterObservation struct {
}

type PacketFilterParameters struct {

	// DDoS feature filtering configuration detail.
	// +kubebuilder:validation:Optional
	PacketFilters []PacketFiltersParameters `json:"packetFilters,omitempty" tf:"packet_filters,omitempty"`

	// - `on`: Enable. `PacketFilters` parameter is required.- `off`: Disable.
	// +kubebuilder:validation:Optional
	Switch *string `json:"switch,omitempty" tf:"switch,omitempty"`
}

type PacketFiltersObservation struct {
}

type PacketFiltersParameters struct {

	// Action to take. Valid values: `drop`, `transmit`, `drop_block`, `forward`.
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Packet character depth to check of feature 1. Valid value range: 1-1500.
	// +kubebuilder:validation:Optional
	Depth *float64 `json:"depth,omitempty" tf:"depth,omitempty"`

	// Packet character depth to check of feature 2. Valid value range: 1-1500.
	// +kubebuilder:validation:Optional
	Depth2 *float64 `json:"depth2,omitempty" tf:"depth2,omitempty"`

	// End of the dest port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	DportEnd *float64 `json:"dportEnd,omitempty" tf:"dport_end,omitempty"`

	// Start of the dest port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	DportStart *float64 `json:"dportStart,omitempty" tf:"dport_start,omitempty"`

	// Negate the match condition of feature 1. Valid values:- `0`: match.- `1`: not match.
	// +kubebuilder:validation:Optional
	IsNot *float64 `json:"isNot,omitempty" tf:"is_not,omitempty"`

	// Negate the match condition of feature 2. Valid values:- `0`: match.- `1`: not match.
	// +kubebuilder:validation:Optional
	IsNot2 *float64 `json:"isNot2,omitempty" tf:"is_not2,omitempty"`

	// Packet layer for matching begin of feature 1. Valid values:- `begin_l5`: matching from packet payload.- `begin_l4`: matching from TCP/UDP header.- `begin_l3`: matching from IP header.
	// +kubebuilder:validation:Optional
	MatchBegin *string `json:"matchBegin,omitempty" tf:"match_begin,omitempty"`

	// Packet layer for matching begin of feature 2. Valid values:- `begin_l5`: matching from packet payload.- `begin_l4`: matching from TCP/UDP header.- `begin_l3`: matching from IP header.
	// +kubebuilder:validation:Optional
	MatchBegin2 *string `json:"matchBegin2,omitempty" tf:"match_begin2,omitempty"`

	// Relation between multi features. Valid values: `and`, `or`, `none` (only feature 1 is used).
	// +kubebuilder:validation:Optional
	MatchLogic *string `json:"matchLogic,omitempty" tf:"match_logic,omitempty"`

	// Match type of feature 1. Valid values:- `pcre`: regex expression.- `sunday`: string match.
	// +kubebuilder:validation:Optional
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	// Match type of feature 2. Valid values:- `pcre`: regex expression.- `sunday`: string match.
	// +kubebuilder:validation:Optional
	MatchType2 *string `json:"matchType2,omitempty" tf:"match_type2,omitempty"`

	// Offset of feature 1. Valid value range: 1-1500.
	// +kubebuilder:validation:Optional
	Offset *float64 `json:"offset,omitempty" tf:"offset,omitempty"`

	// Offset of feature 2. Valid value range: 1-1500.
	// +kubebuilder:validation:Optional
	Offset2 *float64 `json:"offset2,omitempty" tf:"offset2,omitempty"`

	// Max packet size. Valid value range: 0-1500.
	// +kubebuilder:validation:Optional
	PacketMax *float64 `json:"packetMax,omitempty" tf:"packet_max,omitempty"`

	// Min packet size. Valid value range: 0-1500.
	// +kubebuilder:validation:Optional
	PacketMin *float64 `json:"packetMin,omitempty" tf:"packet_min,omitempty"`

	// Valid value: `tcp`, `udp`, `icmp`, `all`.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// End of the source port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	SportEnd *float64 `json:"sportEnd,omitempty" tf:"sport_end,omitempty"`

	// Start of the source port range. Valid value range: 0-65535.
	// +kubebuilder:validation:Optional
	SportStart *float64 `json:"sportStart,omitempty" tf:"sport_start,omitempty"`

	// Regex expression or string to match.
	// +kubebuilder:validation:Optional
	Str *string `json:"str,omitempty" tf:"str,omitempty"`

	// Regex expression or string to match.
	// +kubebuilder:validation:Optional
	Str2 *string `json:"str2,omitempty" tf:"str2,omitempty"`
}

type SpeedLimitObservation struct {
}

type SpeedLimitParameters struct {

	// Limit the number of fluxes. Valid range: 1 bps-10000 Gbps, 0 means no limitation, supported units: `pps`,`Kpps`,`Mpps`,`Gpps`.
	// +kubebuilder:validation:Optional
	FluxLimit *string `json:"fluxLimit,omitempty" tf:"flux_limit,omitempty"`

	// Limit the number of packages. Valid range: 1 pps-10000 Gpps, 0 means no limitation, supported units: `pps`,`Kpps`,`Mpps`,`Gpps`.
	// +kubebuilder:validation:Optional
	PackageLimit *string `json:"packageLimit,omitempty" tf:"package_limit,omitempty"`
}

type StatusInfoObservation struct {
}

type StatusInfoParameters struct {

	// Policy level. Valid values:- `low`: loose.- `middle`: moderate.- `high`: strict.
	// +kubebuilder:validation:Required
	PlyLevel *string `json:"plyLevel" tf:"ply_level,omitempty"`
}

// DDosPolicySpec defines the desired state of DDosPolicy
type DDosPolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DDosPolicyParameters `json:"forProvider"`
}

// DDosPolicyStatus defines the observed state of DDosPolicy.
type DDosPolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DDosPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DDosPolicy is the Schema for the DDosPolicys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type DDosPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DDosPolicySpec   `json:"spec"`
	Status            DDosPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DDosPolicyList contains a list of DDosPolicys
type DDosPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DDosPolicy `json:"items"`
}

// Repository type metadata.
var (
	DDosPolicy_Kind             = "DDosPolicy"
	DDosPolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DDosPolicy_Kind}.String()
	DDosPolicy_KindAPIVersion   = DDosPolicy_Kind + "." + CRDGroupVersion.String()
	DDosPolicy_GroupVersionKind = CRDGroupVersion.WithKind(DDosPolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&DDosPolicy{}, &DDosPolicyList{})
}
