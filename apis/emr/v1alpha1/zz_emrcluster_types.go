/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CommonResourceSpecObservation struct {
}

type CommonResourceSpecParameters struct {

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// +kubebuilder:validation:Optional
	MemSize *float64 `json:"memSize,omitempty" tf:"mem_size,omitempty"`

	// +kubebuilder:validation:Optional
	RootSize *float64 `json:"rootSize,omitempty" tf:"root_size,omitempty"`

	// +kubebuilder:validation:Optional
	Spec *string `json:"spec,omitempty" tf:"spec,omitempty"`

	// +kubebuilder:validation:Optional
	StorageType *float64 `json:"storageType,omitempty" tf:"storage_type,omitempty"`
}

type CoreResourceSpecObservation struct {
}

type CoreResourceSpecParameters struct {

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// +kubebuilder:validation:Optional
	MemSize *float64 `json:"memSize,omitempty" tf:"mem_size,omitempty"`

	// +kubebuilder:validation:Optional
	RootSize *float64 `json:"rootSize,omitempty" tf:"root_size,omitempty"`

	// +kubebuilder:validation:Optional
	Spec *string `json:"spec,omitempty" tf:"spec,omitempty"`

	// +kubebuilder:validation:Optional
	StorageType *float64 `json:"storageType,omitempty" tf:"storage_type,omitempty"`
}

type EmrClusterObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`
}

type EmrClusterParameters struct {

	// Display strategy of EMR instance.
	// +kubebuilder:validation:Required
	DisplayStrategy *string `json:"displayStrategy" tf:"display_strategy,omitempty"`

	// Access the external file system.
	// +kubebuilder:validation:Optional
	ExtendFsField *string `json:"extendFsField,omitempty" tf:"extend_fs_field,omitempty"`

	// Name of the instance, which can contain 6 to 36 English letters, Chinese characters, digits, dashes(-), or underscores(_).
	// +kubebuilder:validation:Required
	InstanceName *string `json:"instanceName" tf:"instance_name,omitempty"`

	// Instance login settings.
	// +kubebuilder:validation:Required
	LoginSettings map[string]*string `json:"loginSettings" tf:"login_settings,omitempty"`

	// Whether to enable the cluster Master node public network. Value range:
	// - NEED_MASTER_WAN: Indicates that the cluster Master node public network is enabled.
	// - NOT_NEED_MASTER_WAN: Indicates that it is not turned on.
	// By default, the cluster Master node internet is enabled.
	// +kubebuilder:validation:Optional
	NeedMasterWan *string `json:"needMasterWan,omitempty" tf:"need_master_wan,omitempty"`

	// The pay mode of instance. 0 represent POSTPAID_BY_HOUR, 1 represent PREPAID.
	// +kubebuilder:validation:Required
	PayMode *float64 `json:"payMode" tf:"pay_mode,omitempty"`

	// The location of the instance.
	// +kubebuilder:validation:Required
	Placement map[string]*string `json:"placement" tf:"placement,omitempty"`

	// Product ID. Different products ID represents different EMR product versions. Value range:
	// - 16: represents EMR-V2.3.0
	// - 20: indicates EMR-V2.5.0
	// - 25: represents EMR-V3.1.0
	// - 27: represents KAFKA-V1.0.0
	// - 30: indicates EMR-V2.6.0
	// - 33: represents EMR-V3.2.1
	// - 34: stands for EMR-V3.3.0
	// - 36: represents STARROCKS-V1.0.0
	// - 37: indicates EMR-V3.4.0
	// - 38: represents EMR-V2.7.0
	// - 39: stands for STARROCKS-V1.1.0
	// - 41: represents DRUID-V1.1.0.
	// +kubebuilder:validation:Required
	ProductID *float64 `json:"productId" tf:"product_id,omitempty"`

	// Resource specification of EMR instance.
	// +kubebuilder:validation:Optional
	ResourceSpec []ResourceSpecParameters `json:"resourceSpec,omitempty" tf:"resource_spec,omitempty"`

	// The ID of the security group to which the instance belongs, in the form of sg-xxxxxxxx.
	// +kubebuilder:validation:Optional
	SgID *string `json:"sgId,omitempty" tf:"sg_id,omitempty"`

	// The softwares of a EMR instance.
	// +kubebuilder:validation:Required
	Softwares []*string `json:"softwares" tf:"softwares,omitempty"`

	// The flag whether the instance support high availability.(0=>not support, 1=>support).
	// +kubebuilder:validation:Required
	SupportHa *float64 `json:"supportHa" tf:"support_ha,omitempty"`

	// Tag description list.
	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The length of time the instance was purchased. Use with TimeUnit.When TimeUnit is s, the parameter can only be filled in at 3600, representing a metered instance.
	// When TimeUnit is m, the number filled in by this parameter indicates the length of purchase of the monthly instance of the package year, such as 1 for one month of purchase.
	// +kubebuilder:validation:Required
	TimeSpan *float64 `json:"timeSpan" tf:"time_span,omitempty"`

	// The unit of time in which the instance was purchased. When PayMode is 0, TimeUnit can only take values of s(second). When PayMode is 1, TimeUnit can only take the value m(month).
	// +kubebuilder:validation:Required
	TimeUnit *string `json:"timeUnit" tf:"time_unit,omitempty"`

	// The private net config of EMR instance.
	// +kubebuilder:validation:Required
	VPCSettings map[string]*string `json:"vpcSettings" tf:"vpc_settings,omitempty"`
}

type MasterResourceSpecObservation struct {
}

type MasterResourceSpecParameters struct {

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// +kubebuilder:validation:Optional
	MemSize *float64 `json:"memSize,omitempty" tf:"mem_size,omitempty"`

	// +kubebuilder:validation:Optional
	RootSize *float64 `json:"rootSize,omitempty" tf:"root_size,omitempty"`

	// +kubebuilder:validation:Optional
	Spec *string `json:"spec,omitempty" tf:"spec,omitempty"`

	// +kubebuilder:validation:Optional
	StorageType *float64 `json:"storageType,omitempty" tf:"storage_type,omitempty"`
}

type ResourceSpecObservation struct {
}

type ResourceSpecParameters struct {

	// The number of common node.
	// +kubebuilder:validation:Optional
	CommonCount *float64 `json:"commonCount,omitempty" tf:"common_count,omitempty"`

	// +kubebuilder:validation:Optional
	CommonResourceSpec []CommonResourceSpecParameters `json:"commonResourceSpec,omitempty" tf:"common_resource_spec,omitempty"`

	// The number of core node.
	// +kubebuilder:validation:Optional
	CoreCount *float64 `json:"coreCount,omitempty" tf:"core_count,omitempty"`

	// +kubebuilder:validation:Optional
	CoreResourceSpec []CoreResourceSpecParameters `json:"coreResourceSpec,omitempty" tf:"core_resource_spec,omitempty"`

	// The number of master node.
	// +kubebuilder:validation:Optional
	MasterCount *float64 `json:"masterCount,omitempty" tf:"master_count,omitempty"`

	// +kubebuilder:validation:Optional
	MasterResourceSpec []MasterResourceSpecParameters `json:"masterResourceSpec,omitempty" tf:"master_resource_spec,omitempty"`

	// The number of core node.
	// +kubebuilder:validation:Optional
	TaskCount *float64 `json:"taskCount,omitempty" tf:"task_count,omitempty"`

	// +kubebuilder:validation:Optional
	TaskResourceSpec []TaskResourceSpecParameters `json:"taskResourceSpec,omitempty" tf:"task_resource_spec,omitempty"`
}

type TaskResourceSpecObservation struct {
}

type TaskResourceSpecParameters struct {

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSize *float64 `json:"diskSize,omitempty" tf:"disk_size,omitempty"`

	// +kubebuilder:validation:Optional
	DiskType *string `json:"diskType,omitempty" tf:"disk_type,omitempty"`

	// +kubebuilder:validation:Optional
	MemSize *float64 `json:"memSize,omitempty" tf:"mem_size,omitempty"`

	// +kubebuilder:validation:Optional
	RootSize *float64 `json:"rootSize,omitempty" tf:"root_size,omitempty"`

	// +kubebuilder:validation:Optional
	Spec *string `json:"spec,omitempty" tf:"spec,omitempty"`

	// +kubebuilder:validation:Optional
	StorageType *float64 `json:"storageType,omitempty" tf:"storage_type,omitempty"`
}

// EmrClusterSpec defines the desired state of EmrCluster
type EmrClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EmrClusterParameters `json:"forProvider"`
}

// EmrClusterStatus defines the observed state of EmrCluster.
type EmrClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EmrClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// EmrCluster is the Schema for the EmrClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type EmrCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EmrClusterSpec   `json:"spec"`
	Status            EmrClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EmrClusterList contains a list of EmrClusters
type EmrClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EmrCluster `json:"items"`
}

// Repository type metadata.
var (
	EmrCluster_Kind             = "EmrCluster"
	EmrCluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: EmrCluster_Kind}.String()
	EmrCluster_KindAPIVersion   = EmrCluster_Kind + "." + CRDGroupVersion.String()
	EmrCluster_GroupVersionKind = CRDGroupVersion.WithKind(EmrCluster_Kind)
)

func init() {
	SchemeBuilder.Register(&EmrCluster{}, &EmrClusterList{})
}
