/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type FullTextObservation struct {
}

type FullTextParameters struct {

	// Case sensitivity.
	// +kubebuilder:validation:Required
	CaseSensitive *bool `json:"caseSensitive" tf:"case_sensitive,omitempty"`

	// Whether Chinese characters are contained.
	// +kubebuilder:validation:Required
	ContainZH *bool `json:"containZH" tf:"contain_z_h,omitempty"`

	// Full-Text index delimiter. Each character in the string represents a delimiter.
	// +kubebuilder:validation:Required
	Tokenizer *string `json:"tokenizer" tf:"tokenizer,omitempty"`
}

type IndexObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type IndexParameters struct {

	// Internal field marker of full-text index. Default value: false. Valid value: false: excluding internal fields; true: including internal fields.
	// +kubebuilder:validation:Optional
	IncludeInternalFields *bool `json:"includeInternalFields,omitempty" tf:"include_internal_fields,omitempty"`

	// Metadata flag. Default value: 0. Valid value: 0: full-text index (including the metadata field with key-value index enabled); 1: full-text index (including all metadata fields); 2: full-text index (excluding metadata fields)..
	// +kubebuilder:validation:Optional
	MetadataFlag *float64 `json:"metadataFlag,omitempty" tf:"metadata_flag,omitempty"`

	// Index rule.
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule,omitempty" tf:"rule,omitempty"`

	// Whether to take effect. Default value: true.
	// +kubebuilder:validation:Optional
	Status *bool `json:"status,omitempty" tf:"status,omitempty"`

	// Log topic ID.
	// +crossplane:generate:reference:type=Topic
	// +kubebuilder:validation:Optional
	TopicID *string `json:"topicId,omitempty" tf:"topic_id,omitempty"`

	// +kubebuilder:validation:Optional
	TopicIDRef *v1.Reference `json:"topicIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TopicIDSelector *v1.Selector `json:"topicIdSelector,omitempty" tf:"-"`
}

type KeyValueObservation struct {
}

type KeyValueParameters struct {

	// Case sensitivity.
	// +kubebuilder:validation:Required
	CaseSensitive *bool `json:"caseSensitive" tf:"case_sensitive,omitempty"`

	// Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
	// +kubebuilder:validation:Optional
	KeyValues []KeyValuesParameters `json:"keyValues,omitempty" tf:"key_values,omitempty"`
}

type KeyValuesObservation struct {
}

type KeyValuesParameters struct {

	// When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Field index description information.
	// +kubebuilder:validation:Optional
	Value []ValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type KeyValuesValueObservation struct {
}

type KeyValuesValueParameters struct {

	// Whether Chinese characters are contained.
	// +kubebuilder:validation:Optional
	ContainZH *bool `json:"containZH,omitempty" tf:"contain_z_h,omitempty"`

	// Whether the analysis feature is enabled for the field.
	// +kubebuilder:validation:Optional
	SQLFlag *bool `json:"sqlFlag,omitempty" tf:"sql_flag,omitempty"`

	// Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
	// +kubebuilder:validation:Optional
	Tokenizer *string `json:"tokenizer,omitempty" tf:"tokenizer,omitempty"`

	// Field type. Valid values: long, text, double.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type RuleObservation struct {
}

type RuleParameters struct {

	// Full-Text index configuration.
	// +kubebuilder:validation:Optional
	FullText []FullTextParameters `json:"fullText,omitempty" tf:"full_text,omitempty"`

	// Key-Value index configuration.
	// +kubebuilder:validation:Optional
	KeyValue []KeyValueParameters `json:"keyValue,omitempty" tf:"key_value,omitempty"`

	// Metafield index configuration.
	// +kubebuilder:validation:Optional
	Tag []TagParameters `json:"tag,omitempty" tf:"tag,omitempty"`
}

type TagKeyValuesObservation struct {
}

type TagKeyValuesParameters struct {

	// When a key value or metafield index needs to be configured for a field, the metafield Key does not need to be prefixed with __TAG__. and is consistent with the one when logs are uploaded. __TAG__. will be prefixed automatically for display in the console..
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Field index description information.
	// +kubebuilder:validation:Optional
	Value []KeyValuesValueParameters `json:"value,omitempty" tf:"value,omitempty"`
}

type TagObservation struct {
}

type TagParameters struct {

	// Case sensitivity.
	// +kubebuilder:validation:Required
	CaseSensitive *bool `json:"caseSensitive" tf:"case_sensitive,omitempty"`

	// Key-Value pair information of the index to be created. Up to 100 key-value pairs can be configured.
	// +kubebuilder:validation:Optional
	KeyValues []TagKeyValuesParameters `json:"keyValues,omitempty" tf:"key_values,omitempty"`
}

type ValueObservation struct {
}

type ValueParameters struct {

	// Whether Chinese characters are contained.
	// +kubebuilder:validation:Optional
	ContainZH *bool `json:"containZH,omitempty" tf:"contain_z_h,omitempty"`

	// Whether the analysis feature is enabled for the field.
	// +kubebuilder:validation:Optional
	SQLFlag *bool `json:"sqlFlag,omitempty" tf:"sql_flag,omitempty"`

	// Field delimiter, which is meaningful only if the field type is text. Each character in the entered string represents a delimiter.
	// +kubebuilder:validation:Optional
	Tokenizer *string `json:"tokenizer,omitempty" tf:"tokenizer,omitempty"`

	// Field type. Valid values: long, text, double.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

// IndexSpec defines the desired state of Index
type IndexSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     IndexParameters `json:"forProvider"`
}

// IndexStatus defines the observed state of Index.
type IndexStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        IndexObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Index is the Schema for the Indexs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Index struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              IndexSpec   `json:"spec"`
	Status            IndexStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// IndexList contains a list of Indexs
type IndexList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Index `json:"items"`
}

// Repository type metadata.
var (
	Index_Kind             = "Index"
	Index_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Index_Kind}.String()
	Index_KindAPIVersion   = Index_Kind + "." + CRDGroupVersion.String()
	Index_GroupVersionKind = CRDGroupVersion.WithKind(Index_Kind)
)

func init() {
	SchemeBuilder.Register(&Index{}, &IndexList{})
}
