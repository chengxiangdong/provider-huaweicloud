/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigExtraExcludePathsObservation struct {
}

type ConfigExtraExcludePathsParameters struct {

	// Type. Valid values: File, Path.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Specific content corresponding to Type.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ConfigExtraExtractRuleObservation struct {
}

type ConfigExtraExtractRuleParameters struct {

	// Size of the data to be rewound in incremental collection mode. Default value: -1 (full collection).
	// +kubebuilder:validation:Optional
	Backtracking *float64 `json:"backtracking,omitempty" tf:"backtracking,omitempty"`

	// First-Line matching rule, which is valid only if log_type is multiline_log or fullregex_log.
	// +kubebuilder:validation:Optional
	BeginRegex *string `json:"beginRegex,omitempty" tf:"begin_regex,omitempty"`

	// Delimiter for delimited log, which is valid only if log_type is delimiter_log.
	// +kubebuilder:validation:Optional
	Delimiter *string `json:"delimiter,omitempty" tf:"delimiter,omitempty"`

	// Log keys to be filtered and the corresponding regex.
	// +kubebuilder:validation:Optional
	FilterKeyRegex []ExtractRuleFilterKeyRegexParameters `json:"filterKeyRegex,omitempty" tf:"filter_key_regex,omitempty"`

	// Key name of each extracted field. An empty key indicates to discard the field. This parameter is valid only if log_type is delimiter_log. json_log logs use the key of JSON itself.
	// +kubebuilder:validation:Optional
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// Full log matching rule, which is valid only if log_type is fullregex_log.
	// +kubebuilder:validation:Optional
	LogRegex *string `json:"logRegex,omitempty" tf:"log_regex,omitempty"`

	// Time field format. For more information, please see the output parameters of the time format description of the strftime function in C language.
	// +kubebuilder:validation:Optional
	TimeFormat *string `json:"timeFormat,omitempty" tf:"time_format,omitempty"`

	// Time field key name. time_key and time_format must appear in pair.
	// +kubebuilder:validation:Optional
	TimeKey *string `json:"timeKey,omitempty" tf:"time_key,omitempty"`

	// Unmatched log key.
	// +kubebuilder:validation:Optional
	UnMatchLogKey *string `json:"unMatchLogKey,omitempty" tf:"un_match_log_key,omitempty"`

	// Whether to upload the logs that failed to be parsed. Valid values: true: yes; false: no.
	// +kubebuilder:validation:Optional
	UnMatchUpLoadSwitch *bool `json:"unMatchUpLoadSwitch,omitempty" tf:"un_match_up_load_switch,omitempty"`
}

type ConfigExtraObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ConfigExtraParameters struct {

	// Collection configuration flag.
	// +kubebuilder:validation:Required
	ConfigFlag *string `json:"configFlag" tf:"config_flag,omitempty"`

	// Container file path info.
	// +kubebuilder:validation:Optional
	ContainerFile []ContainerFileParameters `json:"containerFile,omitempty" tf:"container_file,omitempty"`

	// Container stdout info.
	// +kubebuilder:validation:Optional
	ContainerStdout []ContainerStdoutParameters `json:"containerStdout,omitempty" tf:"container_stdout,omitempty"`

	// Collection path blocklist.
	// +kubebuilder:validation:Optional
	ExcludePaths []ConfigExtraExcludePathsParameters `json:"excludePaths,omitempty" tf:"exclude_paths,omitempty"`

	// Extraction rule. If ExtractRule is set, LogType must be set.
	// +kubebuilder:validation:Optional
	ExtractRule []ConfigExtraExtractRuleParameters `json:"extractRule,omitempty" tf:"extract_rule,omitempty"`

	// Binding group id.
	// +kubebuilder:validation:Optional
	GroupID *string `json:"groupId,omitempty" tf:"group_id,omitempty"`

	// Binding group ids.
	// +kubebuilder:validation:Optional
	GroupIds []*string `json:"groupIds,omitempty" tf:"group_ids,omitempty"`

	// Node file config info.
	// +kubebuilder:validation:Optional
	HostFile []HostFileParameters `json:"hostFile,omitempty" tf:"host_file,omitempty"`

	// Log format.
	// +kubebuilder:validation:Optional
	LogFormat *string `json:"logFormat,omitempty" tf:"log_format,omitempty"`

	// Type of the log to be collected. Valid values: json_log: log in JSON format; delimiter_log: log in delimited format; minimalist_log: minimalist log; multiline_log: log in multi-line format; fullregex_log: log in full regex format. Default value: minimalist_log.
	// +kubebuilder:validation:Required
	LogType *string `json:"logType" tf:"log_type,omitempty"`

	// Logset Id.
	// +crossplane:generate:reference:type=Logset
	// +kubebuilder:validation:Optional
	LogsetID *string `json:"logsetId,omitempty" tf:"logset_id,omitempty"`

	// +kubebuilder:validation:Optional
	LogsetIDRef *v1.Reference `json:"logsetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	LogsetIDSelector *v1.Selector `json:"logsetIdSelector,omitempty" tf:"-"`

	// Logset Name.
	// +kubebuilder:validation:Required
	LogsetName *string `json:"logsetName" tf:"logset_name,omitempty"`

	// Collection configuration name.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Log topic ID (TopicId) of collection configuration.
	// +crossplane:generate:reference:type=Topic
	// +kubebuilder:validation:Optional
	TopicID *string `json:"topicId,omitempty" tf:"topic_id,omitempty"`

	// +kubebuilder:validation:Optional
	TopicIDRef *v1.Reference `json:"topicIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TopicIDSelector *v1.Selector `json:"topicIdSelector,omitempty" tf:"-"`

	// Topic Name.
	// +kubebuilder:validation:Required
	TopicName *string `json:"topicName" tf:"topic_name,omitempty"`

	// Type. Valid values: container_stdout; container_file; host_file.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// Custom collection rule, which is a serialized JSON string.
	// +kubebuilder:validation:Optional
	UserDefineRule *string `json:"userDefineRule,omitempty" tf:"user_define_rule,omitempty"`
}

type ContainerFileObservation struct {
}

type ContainerFileParameters struct {

	// Container name.
	// +kubebuilder:validation:Required
	Container *string `json:"container" tf:"container,omitempty"`

	// Pod label to be excluded.
	// +kubebuilder:validation:Optional
	ExcludeLabels []*string `json:"excludeLabels,omitempty" tf:"exclude_labels,omitempty"`

	// Namespaces to be excluded, separated by separators, such as A, B.
	// +kubebuilder:validation:Optional
	ExcludeNamespace *string `json:"excludeNamespace,omitempty" tf:"exclude_namespace,omitempty"`

	// log name.
	// +kubebuilder:validation:Required
	FilePattern *string `json:"filePattern" tf:"file_pattern,omitempty"`

	// Pod label info.
	// +kubebuilder:validation:Optional
	IncludeLabels []*string `json:"includeLabels,omitempty" tf:"include_labels,omitempty"`

	// Log Path.
	// +kubebuilder:validation:Required
	LogPath *string `json:"logPath" tf:"log_path,omitempty"`

	// Namespace. There can be multiple namespaces, separated by separators, such as A, B.
	// +kubebuilder:validation:Required
	Namespace *string `json:"namespace" tf:"namespace,omitempty"`

	// Workload info.
	// +kubebuilder:validation:Optional
	Workload []WorkloadParameters `json:"workload,omitempty" tf:"workload,omitempty"`
}

type ContainerStdoutObservation struct {
}

type ContainerStdoutParameters struct {

	// Is all containers.
	// +kubebuilder:validation:Required
	AllContainers *bool `json:"allContainers" tf:"all_containers,omitempty"`

	// Pod label to be excluded.
	// +kubebuilder:validation:Optional
	ExcludeLabels []*string `json:"excludeLabels,omitempty" tf:"exclude_labels,omitempty"`

	// Namespaces to be excluded, separated by separators, such as A, B.
	// +kubebuilder:validation:Optional
	ExcludeNamespace *string `json:"excludeNamespace,omitempty" tf:"exclude_namespace,omitempty"`

	// Pod label info.
	// +kubebuilder:validation:Optional
	IncludeLabels []*string `json:"includeLabels,omitempty" tf:"include_labels,omitempty"`

	// Namespace. There can be multiple namespaces, separated by separators, such as A, B.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// Workload info.
	// +kubebuilder:validation:Optional
	Workloads []WorkloadsParameters `json:"workloads,omitempty" tf:"workloads,omitempty"`
}

type ExtractRuleFilterKeyRegexObservation struct {
}

type ExtractRuleFilterKeyRegexParameters struct {

	// Log key to be filtered.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Filter rule regex corresponding to key.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`
}

type HostFileObservation struct {
}

type HostFileParameters struct {

	// Metadata info.
	// +kubebuilder:validation:Optional
	CustomLabels []*string `json:"customLabels,omitempty" tf:"custom_labels,omitempty"`

	// Log file name.
	// +kubebuilder:validation:Required
	FilePattern *string `json:"filePattern" tf:"file_pattern,omitempty"`

	// Log file dir.
	// +kubebuilder:validation:Required
	LogPath *string `json:"logPath" tf:"log_path,omitempty"`
}

type WorkloadObservation struct {
}

type WorkloadParameters struct {

	// container name.
	// +kubebuilder:validation:Optional
	Container *string `json:"container,omitempty" tf:"container,omitempty"`

	// workload type.
	// +kubebuilder:validation:Required
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// workload name.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

type WorkloadsObservation struct {
}

type WorkloadsParameters struct {

	// container name.
	// +kubebuilder:validation:Optional
	Container *string `json:"container,omitempty" tf:"container,omitempty"`

	// workload type.
	// +kubebuilder:validation:Required
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// workload name.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// namespace.
	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`
}

// ConfigExtraSpec defines the desired state of ConfigExtra
type ConfigExtraSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ConfigExtraParameters `json:"forProvider"`
}

// ConfigExtraStatus defines the observed state of ConfigExtra.
type ConfigExtraStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ConfigExtraObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigExtra is the Schema for the ConfigExtras API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type ConfigExtra struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ConfigExtraSpec   `json:"spec"`
	Status            ConfigExtraStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigExtraList contains a list of ConfigExtras
type ConfigExtraList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ConfigExtra `json:"items"`
}

// Repository type metadata.
var (
	ConfigExtra_Kind             = "ConfigExtra"
	ConfigExtra_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ConfigExtra_Kind}.String()
	ConfigExtra_KindAPIVersion   = ConfigExtra_Kind + "." + CRDGroupVersion.String()
	ConfigExtra_GroupVersionKind = CRDGroupVersion.WithKind(ConfigExtra_Kind)
)

func init() {
	SchemeBuilder.Register(&ConfigExtra{}, &ConfigExtraList{})
}
