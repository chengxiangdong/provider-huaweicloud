/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CompressObservation struct {
}

type CompressParameters struct {

	// Compression format. Valid values: gzip, lzop, none (no compression).
	// +kubebuilder:validation:Required
	Format *string `json:"format" tf:"format,omitempty"`
}

type ContentObservation struct {
}

type ContentParameters struct {

	// CSV format content description.Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Optional
	Csv []CsvParameters `json:"csv,omitempty" tf:"csv,omitempty"`

	// Content format. Valid values: json, csv.
	// +kubebuilder:validation:Required
	Format *string `json:"format" tf:"format,omitempty"`

	// JSON format content description.Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Optional
	JSON []JSONParameters `json:"json,omitempty" tf:"json,omitempty"`
}

type CosShipperObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type CosShipperParameters struct {

	// Destination bucket in the shipping rule to be created.
	// +kubebuilder:validation:Required
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// Compression configuration of shipped log.
	// +kubebuilder:validation:Optional
	Compress []CompressParameters `json:"compress,omitempty" tf:"compress,omitempty"`

	// Format configuration of shipped log content.
	// +kubebuilder:validation:Optional
	Content []ContentParameters `json:"content,omitempty" tf:"content,omitempty"`

	// Filter rules for shipped logs. Only logs matching the rules can be shipped. All rules are in the AND relationship, and up to five rules can be added. If the array is empty, no filtering will be performed, and all logs will be shipped.
	// +kubebuilder:validation:Optional
	FilterRules []FilterRulesParameters `json:"filterRules,omitempty" tf:"filter_rules,omitempty"`

	// Shipping time interval in seconds. Default value: 300. Value range: 300~900.
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Maximum size of a file to be shipped, in MB. Default value: 256. Value range: 100~256.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Partition rule of shipped log, which can be represented in strftime time format.
	// +kubebuilder:validation:Optional
	Partition *string `json:"partition,omitempty" tf:"partition,omitempty"`

	// Prefix of the shipping directory in the shipping rule to be created.
	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// Shipping rule name.
	// +kubebuilder:validation:Required
	ShipperName *string `json:"shipperName" tf:"shipper_name,omitempty"`

	// ID of the log topic to which the shipping rule to be created belongs.
	// +crossplane:generate:reference:type=Topic
	// +kubebuilder:validation:Optional
	TopicID *string `json:"topicId,omitempty" tf:"topic_id,omitempty"`

	// +kubebuilder:validation:Optional
	TopicIDRef *v1.Reference `json:"topicIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TopicIDSelector *v1.Selector `json:"topicIdSelector,omitempty" tf:"-"`
}

type CsvObservation struct {
}

type CsvParameters struct {

	// Field delimiter.
	// +kubebuilder:validation:Required
	Delimiter *string `json:"delimiter" tf:"delimiter,omitempty"`

	// Field delimiter.
	// +kubebuilder:validation:Required
	EscapeChar *string `json:"escapeChar" tf:"escape_char,omitempty"`

	// Names of keys.Note: this field may return null, indicating that no valid values can be obtained.
	// +kubebuilder:validation:Required
	Keys []*string `json:"keys" tf:"keys,omitempty"`

	// Content used to populate non-existing fields.
	// +kubebuilder:validation:Required
	NonExistingField *string `json:"nonExistingField" tf:"non_existing_field,omitempty"`

	// Whether to print key on the first row of the CSV file.
	// +kubebuilder:validation:Required
	PrintKey *bool `json:"printKey" tf:"print_key,omitempty"`
}

type FilterRulesObservation struct {
}

type FilterRulesParameters struct {

	// Filter rule key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Filter rule.
	// +kubebuilder:validation:Required
	Regex *string `json:"regex" tf:"regex,omitempty"`

	// Filter rule value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type JSONObservation struct {
}

type JSONParameters struct {

	// Enablement flag.
	// +kubebuilder:validation:Required
	EnableTag *bool `json:"enableTag" tf:"enable_tag,omitempty"`

	// Metadata information list
	// Note: this field may return null, indicating that no valid values can be obtained..
	// +kubebuilder:validation:Required
	MetaFields []*string `json:"metaFields" tf:"meta_fields,omitempty"`
}

// CosShipperSpec defines the desired state of CosShipper
type CosShipperSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CosShipperParameters `json:"forProvider"`
}

// CosShipperStatus defines the observed state of CosShipper.
type CosShipperStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CosShipperObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// CosShipper is the Schema for the CosShippers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type CosShipper struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              CosShipperSpec   `json:"spec"`
	Status            CosShipperStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CosShipperList contains a list of CosShippers
type CosShipperList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CosShipper `json:"items"`
}

// Repository type metadata.
var (
	CosShipper_Kind             = "CosShipper"
	CosShipper_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: CosShipper_Kind}.String()
	CosShipper_KindAPIVersion   = CosShipper_Kind + "." + CRDGroupVersion.String()
	CosShipper_GroupVersionKind = CRDGroupVersion.WithKind(CosShipper_Kind)
)

func init() {
	SchemeBuilder.Register(&CosShipper{}, &CosShipperList{})
}
