/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PushHistoryObservation struct {
	Area *string `json:"area,omitempty" tf:"area,omitempty"`

	CreateTime *string `json:"createTime,omitempty" tf:"create_time,omitempty"`

	Percent *float64 `json:"percent,omitempty" tf:"percent,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	TaskID *string `json:"taskId,omitempty" tf:"task_id,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	UpdateTime *string `json:"updateTime,omitempty" tf:"update_time,omitempty"`
}

type PushHistoryParameters struct {
}

type UrlPushObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	PushHistory []PushHistoryObservation `json:"pushHistory,omitempty" tf:"push_history,omitempty"`

	TaskID *string `json:"taskId,omitempty" tf:"task_id,omitempty"`
}

type UrlPushParameters struct {

	// Specify push area. NOTE: only push same area cache contents.
	// +kubebuilder:validation:Optional
	Area *string `json:"area,omitempty" tf:"area,omitempty"`

	// Layer to push.
	// +kubebuilder:validation:Optional
	Layer *string `json:"layer,omitempty" tf:"layer,omitempty"`

	// Whether to recursive parse m3u8 files.
	// +kubebuilder:validation:Optional
	ParseM3U8 *bool `json:"parseM3U8,omitempty" tf:"parse_m3u8,omitempty"`

	// Change to push again. NOTE: this argument only works while resource update, if set to `0` or null will not be triggered.
	// +kubebuilder:validation:Optional
	Redo *float64 `json:"redo,omitempty" tf:"redo,omitempty"`

	// List of url to push. NOTE: urls need include protocol prefix `http://` or `https://`.
	// +kubebuilder:validation:Required
	Urls []*string `json:"urls" tf:"urls,omitempty"`

	// Specify `User-Agent` HTTP header, default: `TencentCdn`.
	// +kubebuilder:validation:Optional
	UserAgent *string `json:"userAgent,omitempty" tf:"user_agent,omitempty"`
}

// UrlPushSpec defines the desired state of UrlPush
type UrlPushSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     UrlPushParameters `json:"forProvider"`
}

// UrlPushStatus defines the observed state of UrlPush.
type UrlPushStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        UrlPushObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// UrlPush is the Schema for the UrlPushs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type UrlPush struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              UrlPushSpec   `json:"spec"`
	Status            UrlPushStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// UrlPushList contains a list of UrlPushs
type UrlPushList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UrlPush `json:"items"`
}

// Repository type metadata.
var (
	UrlPush_Kind             = "UrlPush"
	UrlPush_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: UrlPush_Kind}.String()
	UrlPush_KindAPIVersion   = UrlPush_Kind + "." + CRDGroupVersion.String()
	UrlPush_GroupVersionKind = CRDGroupVersion.WithKind(UrlPush_Kind)
)

func init() {
	SchemeBuilder.Register(&UrlPush{}, &UrlPushList{})
}
