/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DeployStrategyConfObservation struct {
}

type DeployStrategyConfParameters struct {

	// interval between batches.
	// +kubebuilder:validation:Optional
	BatchInterval *float64 `json:"batchInterval,omitempty" tf:"batch_interval,omitempty"`

	// beta batch number.
	// +kubebuilder:validation:Optional
	BetaBatchNum *float64 `json:"betaBatchNum,omitempty" tf:"beta_batch_num,omitempty"`

	// strategy type, 0 means auto, 1 means manual, 2 means manual with beta batch.
	// +kubebuilder:validation:Required
	DeployStrategyType *float64 `json:"deployStrategyType" tf:"deploy_strategy_type,omitempty"`

	// force update.
	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// minimal available instances duration deployment.
	// +kubebuilder:validation:Optional
	MinAvailable *float64 `json:"minAvailable,omitempty" tf:"min_available,omitempty"`

	// total batch number.
	// +kubebuilder:validation:Required
	TotalBatchCount *float64 `json:"totalBatchCount" tf:"total_batch_count,omitempty"`
}

type EnvConfObservation struct {
}

type EnvConfParameters struct {

	// referenced config name when type=referenced.
	// +kubebuilder:validation:Optional
	Config *string `json:"config,omitempty" tf:"config,omitempty"`

	// env key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// referenced secret name when type=referenced.
	// +kubebuilder:validation:Optional
	Secret *string `json:"secret,omitempty" tf:"secret,omitempty"`

	// env type, support default, referenced.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// env value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type LivenessObservation struct {
}

type LivenessParameters struct {

	// script.
	// +kubebuilder:validation:Optional
	Exec *string `json:"exec,omitempty" tf:"exec,omitempty"`

	// initial delay seconds for liveness check.
	// +kubebuilder:validation:Optional
	InitialDelaySeconds *float64 `json:"initialDelaySeconds,omitempty" tf:"initial_delay_seconds,omitempty"`

	// path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// period seconds for liveness check.
	// +kubebuilder:validation:Optional
	PeriodSeconds *float64 `json:"periodSeconds,omitempty" tf:"period_seconds,omitempty"`

	// liveness check port.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// protocol.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// timeout seconds for liveness check.
	// +kubebuilder:validation:Optional
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" tf:"timeout_seconds,omitempty"`

	// check type, support HttpGet, TcpSocket and Exec.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ReadinessObservation struct {
}

type ReadinessParameters struct {

	// script.
	// +kubebuilder:validation:Optional
	Exec *string `json:"exec,omitempty" tf:"exec,omitempty"`

	// initial delay seconds for readiness check.
	// +kubebuilder:validation:Optional
	InitialDelaySeconds *float64 `json:"initialDelaySeconds,omitempty" tf:"initial_delay_seconds,omitempty"`

	// path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// period seconds for readiness check.
	// +kubebuilder:validation:Optional
	PeriodSeconds *float64 `json:"periodSeconds,omitempty" tf:"period_seconds,omitempty"`

	// readiness check port.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// protocol.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// timeout seconds for readiness check.
	// +kubebuilder:validation:Optional
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" tf:"timeout_seconds,omitempty"`

	// check type, support HttpGet, TcpSocket and Exec.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type StartupProbeObservation struct {
}

type StartupProbeParameters struct {

	// script.
	// +kubebuilder:validation:Optional
	Exec *string `json:"exec,omitempty" tf:"exec,omitempty"`

	// initial delay seconds for startup check.
	// +kubebuilder:validation:Optional
	InitialDelaySeconds *float64 `json:"initialDelaySeconds,omitempty" tf:"initial_delay_seconds,omitempty"`

	// path.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// period seconds for startup check.
	// +kubebuilder:validation:Optional
	PeriodSeconds *float64 `json:"periodSeconds,omitempty" tf:"period_seconds,omitempty"`

	// startup check port.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// protocol.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// timeout seconds for startup check.
	// +kubebuilder:validation:Optional
	TimeoutSeconds *float64 `json:"timeoutSeconds,omitempty" tf:"timeout_seconds,omitempty"`

	// check type, support HttpGet, TcpSocket and Exec.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type StorageConfsObservation struct {
}

type StorageConfsParameters struct {

	// volume ip.
	// +kubebuilder:validation:Required
	StorageVolIP *string `json:"storageVolIp" tf:"storage_vol_ip,omitempty"`

	// volume name.
	// +kubebuilder:validation:Required
	StorageVolName *string `json:"storageVolName" tf:"storage_vol_name,omitempty"`

	// volume path.
	// +kubebuilder:validation:Required
	StorageVolPath *string `json:"storageVolPath" tf:"storage_vol_path,omitempty"`
}

type StorageMountConfsObservation struct {
}

type StorageMountConfsParameters struct {

	// mount path.
	// +kubebuilder:validation:Required
	MountPath *string `json:"mountPath" tf:"mount_path,omitempty"`

	// volume name.
	// +kubebuilder:validation:Required
	VolumeName *string `json:"volumeName" tf:"volume_name,omitempty"`
}

type WorkloadObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type WorkloadParameters struct {

	// application ID.
	// +crossplane:generate:reference:type=Application
	// +kubebuilder:validation:Optional
	ApplicationID *string `json:"applicationId,omitempty" tf:"application_id,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationIDRef *v1.Reference `json:"applicationIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ApplicationIDSelector *v1.Selector `json:"applicationIdSelector,omitempty" tf:"-"`

	// cpu.
	// +kubebuilder:validation:Required
	CPUSpec *float64 `json:"cpuSpec" tf:"cpu_spec,omitempty"`

	// deploy mode, support IMAGE.
	// +kubebuilder:validation:Required
	DeployMode *string `json:"deployMode" tf:"deploy_mode,omitempty"`

	// deploy strategy.
	// +kubebuilder:validation:Optional
	DeployStrategyConf []DeployStrategyConfParameters `json:"deployStrategyConf,omitempty" tf:"deploy_strategy_conf,omitempty"`

	// deploy version.
	// +kubebuilder:validation:Required
	DeployVersion *string `json:"deployVersion" tf:"deploy_version,omitempty"`

	// .
	// +kubebuilder:validation:Optional
	EnvConf []EnvConfParameters `json:"envConf,omitempty" tf:"env_conf,omitempty"`

	// environment ID.
	// +crossplane:generate:reference:type=Environment
	// +kubebuilder:validation:Optional
	EnvironmentID *string `json:"environmentId,omitempty" tf:"environment_id,omitempty"`

	// +kubebuilder:validation:Optional
	EnvironmentIDRef *v1.Reference `json:"environmentIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	EnvironmentIDSelector *v1.Selector `json:"environmentIdSelector,omitempty" tf:"-"`

	// repository name.
	// +kubebuilder:validation:Required
	ImgRepo *string `json:"imgRepo" tf:"img_repo,omitempty"`

	// initial pod number.
	// +kubebuilder:validation:Required
	InitPodNum *float64 `json:"initPodNum" tf:"init_pod_num,omitempty"`

	// liveness config.
	// +kubebuilder:validation:Optional
	Liveness []LivenessParameters `json:"liveness,omitempty" tf:"liveness,omitempty"`

	// mem.
	// +kubebuilder:validation:Required
	MemorySpec *float64 `json:"memorySpec" tf:"memory_spec,omitempty"`

	// mem.
	// +kubebuilder:validation:Optional
	PostStart *string `json:"postStart,omitempty" tf:"post_start,omitempty"`

	// mem.
	// +kubebuilder:validation:Optional
	PreStop *string `json:"preStop,omitempty" tf:"pre_stop,omitempty"`

	// .
	// +kubebuilder:validation:Optional
	Readiness []ReadinessParameters `json:"readiness,omitempty" tf:"readiness,omitempty"`

	// repo server addr when deploy by image.
	// +kubebuilder:validation:Optional
	RepoServer *string `json:"repoServer,omitempty" tf:"repo_server,omitempty"`

	// repo type when deploy: 0: tcr personal; 1: tcr enterprise; 2: public repository; 3: tem host tcr; 4: demo repo.
	// +kubebuilder:validation:Optional
	RepoType *float64 `json:"repoType,omitempty" tf:"repo_type,omitempty"`

	// security groups.
	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// .
	// +kubebuilder:validation:Optional
	StartupProbe []StartupProbeParameters `json:"startupProbe,omitempty" tf:"startup_probe,omitempty"`

	// storage configuration.
	// +kubebuilder:validation:Optional
	StorageConfs []StorageConfsParameters `json:"storageConfs,omitempty" tf:"storage_confs,omitempty"`

	// storage mount configuration.
	// +kubebuilder:validation:Optional
	StorageMountConfs []StorageMountConfsParameters `json:"storageMountConfs,omitempty" tf:"storage_mount_confs,omitempty"`

	// tcr instance id when deploy by image.
	// +kubebuilder:validation:Optional
	TcrInstanceID *string `json:"tcrInstanceId,omitempty" tf:"tcr_instance_id,omitempty"`
}

// WorkloadSpec defines the desired state of Workload
type WorkloadSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     WorkloadParameters `json:"forProvider"`
}

// WorkloadStatus defines the observed state of Workload.
type WorkloadStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        WorkloadObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Workload is the Schema for the Workloads API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Workload struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WorkloadSpec   `json:"spec"`
	Status            WorkloadStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// WorkloadList contains a list of Workloads
type WorkloadList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Workload `json:"items"`
}

// Repository type metadata.
var (
	Workload_Kind             = "Workload"
	Workload_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Workload_Kind}.String()
	Workload_KindAPIVersion   = Workload_Kind + "." + CRDGroupVersion.String()
	Workload_GroupVersionKind = CRDGroupVersion.WithKind(Workload_Kind)
)

func init() {
	SchemeBuilder.Register(&Workload{}, &WorkloadList{})
}
