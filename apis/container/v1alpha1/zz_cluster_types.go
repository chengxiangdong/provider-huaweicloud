/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClusterObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	KubernetesVersion *string `json:"kubernetesVersion,omitempty" tf:"kubernetes_version,omitempty"`

	NodesNum *float64 `json:"nodesNum,omitempty" tf:"nodes_num,omitempty"`

	NodesStatus *string `json:"nodesStatus,omitempty" tf:"nodes_status,omitempty"`

	TotalCPU *float64 `json:"totalCpu,omitempty" tf:"total_cpu,omitempty"`

	TotalMem *float64 `json:"totalMem,omitempty" tf:"total_mem,omitempty"`
}

type ClusterParameters struct {

	// The network bandwidth of the node.
	// +kubebuilder:validation:Required
	Bandwidth *float64 `json:"bandwidth" tf:"bandwidth,omitempty"`

	// The network type of the node.
	// +kubebuilder:validation:Required
	BandwidthType *string `json:"bandwidthType" tf:"bandwidth_type,omitempty"`

	// The cpu of the node.
	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// The CIDR which the cluster is going to use.
	// +kubebuilder:validation:Required
	ClusterCidr *string `json:"clusterCidr" tf:"cluster_cidr,omitempty"`

	// The description of the cluster.
	// +kubebuilder:validation:Optional
	ClusterDesc *string `json:"clusterDesc,omitempty" tf:"cluster_desc,omitempty"`

	// The name of the cluster.
	// +kubebuilder:validation:Required
	ClusterName *string `json:"clusterName" tf:"cluster_name,omitempty"`

	// The kubernetes version of the cluster.
	// +kubebuilder:validation:Optional
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version,omitempty"`

	// The type of node needed by cvm.
	// +kubebuilder:validation:Optional
	CvmType *string `json:"cvmType,omitempty" tf:"cvm_type,omitempty"`

	// The docker graph path is going to mounted.
	// +kubebuilder:validation:Optional
	DockerGraphPath *string `json:"dockerGraphPath,omitempty" tf:"docker_graph_path,omitempty"`

	// The node number is going to create in the cluster.
	// +kubebuilder:validation:Required
	GoodsNum *float64 `json:"goodsNum" tf:"goods_num,omitempty"`

	// The name ot node.
	// +kubebuilder:validation:Optional
	InstanceName *string `json:"instanceName,omitempty" tf:"instance_name,omitempty"`

	// The instance type of the node needed by cvm.
	// +kubebuilder:validation:Required
	InstanceType *string `json:"instanceType" tf:"instance_type,omitempty"`

	// Describe whether the node enable the gateway capability.
	// +kubebuilder:validation:Required
	IsVPCGateway *float64 `json:"isVpcGateway" tf:"is_vpc_gateway,omitempty"`

	// The key_id of each node(if using key pair to access).
	// +kubebuilder:validation:Optional
	KeyID *string `json:"keyId,omitempty" tf:"key_id,omitempty"`

	// The memory of the node.
	// +kubebuilder:validation:Optional
	Mem *float64 `json:"mem,omitempty" tf:"mem,omitempty"`

	// The path which volume is going to be mounted.
	// +kubebuilder:validation:Optional
	MountTarget *string `json:"mountTarget,omitempty" tf:"mount_target,omitempty"`

	// The system os name of the node.
	// +kubebuilder:validation:Required
	OsName *string `json:"osName" tf:"os_name,omitempty"`

	// The password of each node.
	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password,omitempty"`

	// The puchase duration of the node needed by cvm.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Indicate whether wan ip is needed.
	// +kubebuilder:validation:Optional
	RequireWanIP *float64 `json:"requireWanIp,omitempty" tf:"require_wan_ip,omitempty"`

	// The size of the root volume.
	// +kubebuilder:validation:Required
	RootSize *float64 `json:"rootSize" tf:"root_size,omitempty"`

	// The type of the root volume. see more from CVM.
	// +kubebuilder:validation:Optional
	RootType *string `json:"rootType,omitempty" tf:"root_type,omitempty"`

	// The security group id.
	// +kubebuilder:validation:Optional
	SgID *string `json:"sgId,omitempty" tf:"sg_id,omitempty"`

	// The size of the data volume.
	// +kubebuilder:validation:Required
	StorageSize *float64 `json:"storageSize" tf:"storage_size,omitempty"`

	// The type of the data volume. see more from CVM.
	// +kubebuilder:validation:Optional
	StorageType *string `json:"storageType,omitempty" tf:"storage_type,omitempty"`

	// The subnet id which the node stays in.
	// +kubebuilder:validation:Required
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`

	// Determine whether the node will be schedulable. 0 is the default meaning node will be schedulable. 1 for unschedulable.
	// +kubebuilder:validation:Optional
	Unschedulable *float64 `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// User defined script in a base64-format. The script runs after the kubernetes component is ready on node. see more from CCS api documents.
	// +kubebuilder:validation:Optional
	UserScript *string `json:"userScript,omitempty" tf:"user_script,omitempty"`

	// Specify vpc which the node(s) stay in.
	// +kubebuilder:validation:Required
	VPCID *string `json:"vpcId" tf:"vpc_id,omitempty"`

	// The zone which the node stays in.
	// +kubebuilder:validation:Required
	ZoneID *string `json:"zoneId" tf:"zone_id,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
