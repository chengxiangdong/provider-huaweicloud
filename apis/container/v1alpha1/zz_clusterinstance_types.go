/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClusterInstanceObservation struct {
	AbnormalReason *string `json:"abnormalReason,omitempty" tf:"abnormal_reason,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	IsNormal *float64 `json:"isNormal,omitempty" tf:"is_normal,omitempty"`

	LanIP *string `json:"lanIp,omitempty" tf:"lan_ip,omitempty"`

	WanIP *string `json:"wanIp,omitempty" tf:"wan_ip,omitempty"`
}

type ClusterInstanceParameters struct {

	// The network bandwidth of the node.
	// +kubebuilder:validation:Required
	Bandwidth *float64 `json:"bandwidth" tf:"bandwidth,omitempty"`

	// The network type of the node.
	// +kubebuilder:validation:Required
	BandwidthType *string `json:"bandwidthType" tf:"bandwidth_type,omitempty"`

	// The cpu of the node.
	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// The id of the cluster.
	// +kubebuilder:validation:Required
	ClusterID *string `json:"clusterId" tf:"cluster_id,omitempty"`

	// The type of node needed by cvm.
	// +kubebuilder:validation:Optional
	CvmType *string `json:"cvmType,omitempty" tf:"cvm_type,omitempty"`

	// The docker graph path is going to mounted.
	// +kubebuilder:validation:Optional
	DockerGraphPath *string `json:"dockerGraphPath,omitempty" tf:"docker_graph_path,omitempty"`

	// The name ot node.
	// +kubebuilder:validation:Optional
	InstanceName *string `json:"instanceName,omitempty" tf:"instance_name,omitempty"`

	// The instance type of the node needed by cvm.
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// Describe whether the node enable the gateway capability.
	// +kubebuilder:validation:Required
	IsVPCGateway *float64 `json:"isVpcGateway" tf:"is_vpc_gateway,omitempty"`

	// The key_id of each node(if using key pair to access).
	// +kubebuilder:validation:Optional
	KeyID *string `json:"keyId,omitempty" tf:"key_id,omitempty"`

	// The memory of the node.
	// +kubebuilder:validation:Optional
	Mem *float64 `json:"mem,omitempty" tf:"mem,omitempty"`

	// The path which volume is going to be mounted.
	// +kubebuilder:validation:Optional
	MountTarget *string `json:"mountTarget,omitempty" tf:"mount_target,omitempty"`

	// The password of each node.
	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password,omitempty"`

	// The puchase duration of the node needed by cvm.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Indicate whether wan ip is needed.
	// +kubebuilder:validation:Optional
	RequireWanIP *float64 `json:"requireWanIp,omitempty" tf:"require_wan_ip,omitempty"`

	// The size of the root volume.
	// +kubebuilder:validation:Required
	RootSize *float64 `json:"rootSize" tf:"root_size,omitempty"`

	// The type of the root volume. see more from CVM.
	// +kubebuilder:validation:Optional
	RootType *string `json:"rootType,omitempty" tf:"root_type,omitempty"`

	// The security group id.
	// +kubebuilder:validation:Optional
	SgID *string `json:"sgId,omitempty" tf:"sg_id,omitempty"`

	// The size of the data volume.
	// +kubebuilder:validation:Required
	StorageSize *float64 `json:"storageSize" tf:"storage_size,omitempty"`

	// The type of the data volume. see more from CVM.
	// +kubebuilder:validation:Optional
	StorageType *string `json:"storageType,omitempty" tf:"storage_type,omitempty"`

	// The subnet id which the node stays in.
	// +kubebuilder:validation:Required
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`

	// Determine whether the node will be schedulable. 0 is the default meaning node will be schedulable. 1 for unschedulable.
	// +kubebuilder:validation:Optional
	Unschedulable *float64 `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// User defined script in a base64-format. The script runs after the kubernetes component is ready on node. see more from CCS api documents.
	// +kubebuilder:validation:Optional
	UserScript *string `json:"userScript,omitempty" tf:"user_script,omitempty"`

	// The zone which the node stays in.
	// +kubebuilder:validation:Required
	ZoneID *string `json:"zoneId" tf:"zone_id,omitempty"`
}

// ClusterInstanceSpec defines the desired state of ClusterInstance
type ClusterInstanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterInstanceParameters `json:"forProvider"`
}

// ClusterInstanceStatus defines the observed state of ClusterInstance.
type ClusterInstanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterInstanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterInstance is the Schema for the ClusterInstances API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type ClusterInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterInstanceSpec   `json:"spec"`
	Status            ClusterInstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterInstanceList contains a list of ClusterInstances
type ClusterInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterInstance `json:"items"`
}

// Repository type metadata.
var (
	ClusterInstance_Kind             = "ClusterInstance"
	ClusterInstance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterInstance_Kind}.String()
	ClusterInstance_KindAPIVersion   = ClusterInstance_Kind + "." + CRDGroupVersion.String()
	ClusterInstance_GroupVersionKind = CRDGroupVersion.WithKind(ClusterInstance_Kind)
)

func init() {
	SchemeBuilder.Register(&ClusterInstance{}, &ClusterInstanceList{})
}
