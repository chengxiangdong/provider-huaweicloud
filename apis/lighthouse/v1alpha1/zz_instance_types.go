/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ContainersObservation struct {
}

type ContainersParameters struct {

	// The command to run.
	// +kubebuilder:validation:Optional
	Command *string `json:"command,omitempty" tf:"command,omitempty"`

	// Container image address.
	// +kubebuilder:validation:Optional
	ContainerImage *string `json:"containerImage,omitempty" tf:"container_image,omitempty"`

	// Container name.
	// +kubebuilder:validation:Optional
	ContainerName *string `json:"containerName,omitempty" tf:"container_name,omitempty"`

	// List of environment variables.
	// +kubebuilder:validation:Optional
	Envs []EnvsParameters `json:"envs,omitempty" tf:"envs,omitempty"`

	// List of mappings of container ports and host ports.
	// +kubebuilder:validation:Optional
	PublishPorts []PublishPortsParameters `json:"publishPorts,omitempty" tf:"publish_ports,omitempty"`

	// List of container mount volumes.
	// +kubebuilder:validation:Optional
	Volumes []VolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`
}

type EnvsObservation struct {
}

type EnvsParameters struct {

	// Environment variable key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Environment variable value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type InstanceObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type InstanceParameters struct {

	// ID of the Lighthouse image.
	// +kubebuilder:validation:Required
	BlueprintID *string `json:"blueprintId" tf:"blueprint_id,omitempty"`

	// ID of the Lighthouse package.
	// +kubebuilder:validation:Required
	BundleID *string `json:"bundleId" tf:"bundle_id,omitempty"`

	// A unique string supplied by the client to ensure that the request is idempotent. Its maximum length is 64 ASCII characters. If this parameter is not specified, the idem-potency of the request cannot be guaranteed.
	// +kubebuilder:validation:Optional
	ClientToken *string `json:"clientToken,omitempty" tf:"client_token,omitempty"`

	// Configuration of the containers to create.
	// +kubebuilder:validation:Optional
	Containers []ContainersParameters `json:"containers,omitempty" tf:"containers,omitempty"`

	// Whether the request is a dry run only.true: dry run only. The request will not create instance(s). A dry run can check whether all the required parameters are specified, whether the request format is right, whether the request exceeds service limits, and whether the specified CVMs are available. If the dry run fails, the corresponding error code will be returned.If the dry run succeeds, the RequestId will be returned.false (default value): send a normal request and create instance(s) if all the requirements are met.
	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// Firewall template ID. If this parameter is not specified, the default firewall policy is used.
	// +kubebuilder:validation:Optional
	FirewallTemplateID *string `json:"firewallTemplateId,omitempty" tf:"firewall_template_id,omitempty"`

	// The display name of the Lighthouse instance.
	// +kubebuilder:validation:Required
	InstanceName *string `json:"instanceName" tf:"instance_name,omitempty"`

	// Whether the voucher is deducted automatically when update bundle id. Value range: `true`: indicates automatic deduction of vouchers, `false`: does not automatically deduct vouchers. Default value: `false`.
	// +kubebuilder:validation:Optional
	IsUpdateBundleIDAutoVoucher *bool `json:"isUpdateBundleIdAutoVoucher,omitempty" tf:"is_update_bundle_id_auto_voucher,omitempty"`

	// Whether to return the mounted data disk. `true`: returns both the instance and the mounted data disk; `false`: returns the instance and no longer returns its mounted data disk. Default: `true`.
	// +kubebuilder:validation:Optional
	IsolateDataDisk *bool `json:"isolateDataDisk,omitempty" tf:"isolate_data_disk,omitempty"`

	// Login password of the instance. It is only available for Windows instances. If it is not specified, it means that the user choose to set the login password after the instance creation.
	// +kubebuilder:validation:Optional
	LoginConfiguration []LoginConfigurationParameters `json:"loginConfiguration,omitempty" tf:"login_configuration,omitempty"`

	// Subscription period in months. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 24, 36, 48, 60.
	// +kubebuilder:validation:Required
	Period *float64 `json:"period" tf:"period,omitempty"`

	// Whether to allow login using the default key pair. `YES`: allow login; `NO`: disable login. Default: `YES`.
	// +kubebuilder:validation:Optional
	PermitDefaultKeyPairLogin *string `json:"permitDefaultKeyPairLogin,omitempty" tf:"permit_default_key_pair_login,omitempty"`

	// Auto-Renewal flag. Valid values: NOTIFY_AND_AUTO_RENEW: notify upon expiration and renew automatically; NOTIFY_AND_MANUAL_RENEW: notify upon expiration but do not renew automatically. You need to manually renew DISABLE_NOTIFY_AND_AUTO_RENEW: neither notify upon expiration nor renew automatically. Default value: NOTIFY_AND_MANUAL_RENEW.
	// +kubebuilder:validation:Required
	RenewFlag *string `json:"renewFlag" tf:"renew_flag,omitempty"`

	// List of availability zones. A random AZ is selected by default.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type LoginConfigurationObservation struct {
}

type LoginConfigurationParameters struct {

	// whether auto generate password. if false, need set password.
	// +kubebuilder:validation:Required
	AutoGeneratePassword *string `json:"autoGeneratePassword" tf:"auto_generate_password,omitempty"`

	// Login password.
	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password,omitempty"`
}

type PublishPortsObservation struct {
}

type PublishPortsParameters struct {

	// Container port.
	// +kubebuilder:validation:Required
	ContainerPort *float64 `json:"containerPort" tf:"container_port,omitempty"`

	// Host port.
	// +kubebuilder:validation:Required
	HostPort *float64 `json:"hostPort" tf:"host_port,omitempty"`

	// External IP. It defaults to 0.0.0.0.
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// The protocol defaults to tcp. Valid values: tcp, udp and sctp.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type VolumesObservation struct {
}

type VolumesParameters struct {

	// Container path.
	// +kubebuilder:validation:Required
	ContainerPath *string `json:"containerPath" tf:"container_path,omitempty"`

	// Host path.
	// +kubebuilder:validation:Required
	HostPath *string `json:"hostPath" tf:"host_path,omitempty"`
}

// InstanceSpec defines the desired state of Instance
type InstanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceParameters `json:"forProvider"`
}

// InstanceStatus defines the observed state of Instance.
type InstanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Instance is the Schema for the Instances API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Instance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              InstanceSpec   `json:"spec"`
	Status            InstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceList contains a list of Instances
type InstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Instance `json:"items"`
}

// Repository type metadata.
var (
	Instance_Kind             = "Instance"
	Instance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Instance_Kind}.String()
	Instance_KindAPIVersion   = Instance_Kind + "." + CRDGroupVersion.String()
	Instance_GroupVersionKind = CRDGroupVersion.WithKind(Instance_Kind)
)

func init() {
	SchemeBuilder.Register(&Instance{}, &InstanceList{})
}
