/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type L4RuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LBType *float64 `json:"lbType,omitempty" tf:"lb_type,omitempty"`

	RuleID *string `json:"ruleId,omitempty" tf:"rule_id,omitempty"`
}

type L4RuleParameters struct {

	// The destination port of the L4 rule.
	// +kubebuilder:validation:Required
	DPort *float64 `json:"dPort" tf:"d_port,omitempty"`

	// Health threshold of health check, and the default is 3. If a success result is returned for the health check 3 consecutive times, indicates that the forwarding is normal. The value range is 2-10.
	// +kubebuilder:validation:Optional
	HealthCheckHealthNum *float64 `json:"healthCheckHealthNum,omitempty" tf:"health_check_health_num,omitempty"`

	// Interval time of health check. The value range is 10-60 sec, and the default is 15 sec.
	// +kubebuilder:validation:Optional
	HealthCheckInterval *float64 `json:"healthCheckInterval,omitempty" tf:"health_check_interval,omitempty"`

	// Indicates whether health check is enabled. The default is `false`. Only valid when source list has more than one source item.
	// +kubebuilder:validation:Optional
	HealthCheckSwitch *bool `json:"healthCheckSwitch,omitempty" tf:"health_check_switch,omitempty"`

	// HTTP Status Code. The default is 26 and value range is 2-60.
	// +kubebuilder:validation:Optional
	HealthCheckTimeout *float64 `json:"healthCheckTimeout,omitempty" tf:"health_check_timeout,omitempty"`

	// Unhealthy threshold of health check, and the default is 3. If the unhealthy result is returned 3 consecutive times, indicates that the forwarding is abnormal. The value range is 2-10.
	// +kubebuilder:validation:Optional
	HealthCheckUnhealthNum *float64 `json:"healthCheckUnhealthNum,omitempty" tf:"health_check_unhealth_num,omitempty"`

	// Protocol of the rule. Valid values: `http`, `https`. When `source_type` is 1(host source), the value of this field can only set with `tcp`.
	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// ID of the resource that the layer 4 rule works for.
	// +kubebuilder:validation:Required
	ResourceID *string `json:"resourceId" tf:"resource_id,omitempty"`

	// Type of the resource that the layer 4 rule works for. Valid values: `bgpip` and `net`.
	// +kubebuilder:validation:Required
	ResourceType *string `json:"resourceType" tf:"resource_type,omitempty"`

	// The source port of the L4 rule.
	// +kubebuilder:validation:Required
	SPort *float64 `json:"sPort" tf:"s_port,omitempty"`

	// Indicate that the session will keep or not, and default value is `false`.
	// +kubebuilder:validation:Optional
	SessionSwitch *bool `json:"sessionSwitch,omitempty" tf:"session_switch,omitempty"`

	// Session keep time, only valid when `session_switch` is true, the available value ranges from 1 to 300 and unit is second.
	// +kubebuilder:validation:Optional
	SessionTime *float64 `json:"sessionTime,omitempty" tf:"session_time,omitempty"`

	// Source list of the rule, it can be a set of ip sources or a set of domain sources. The number of items ranges from 1 to 20.
	// +kubebuilder:validation:Required
	SourceList []SourceListParameters `json:"sourceList" tf:"source_list,omitempty"`

	// Source type, `1` for source of host, `2` for source of IP.
	// +kubebuilder:validation:Required
	SourceType *float64 `json:"sourceType" tf:"source_type,omitempty"`
}

type SourceListObservation struct {
}

type SourceListParameters struct {

	// Source IP or domain, valid format of ip is like `1.1.1.1` and valid format of host source is like `abc.com`.
	// +kubebuilder:validation:Required
	Source *string `json:"source" tf:"source,omitempty"`

	// Weight of the source, the valid value ranges from 0 to 100.
	// +kubebuilder:validation:Required
	Weight *float64 `json:"weight" tf:"weight,omitempty"`
}

// L4RuleSpec defines the desired state of L4Rule
type L4RuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     L4RuleParameters `json:"forProvider"`
}

// L4RuleStatus defines the observed state of L4Rule.
type L4RuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        L4RuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// L4Rule is the Schema for the L4Rules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type L4Rule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              L4RuleSpec   `json:"spec"`
	Status            L4RuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// L4RuleList contains a list of L4Rules
type L4RuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []L4Rule `json:"items"`
}

// Repository type metadata.
var (
	L4Rule_Kind             = "L4Rule"
	L4Rule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: L4Rule_Kind}.String()
	L4Rule_KindAPIVersion   = L4Rule_Kind + "." + CRDGroupVersion.String()
	L4Rule_GroupVersionKind = CRDGroupVersion.WithKind(L4Rule_Kind)
)

func init() {
	SchemeBuilder.Register(&L4Rule{}, &L4RuleList{})
}
