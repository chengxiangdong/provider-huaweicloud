/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApmObservation struct {
}

type ApmParameters struct {

	// Whether enable APM.
	// +kubebuilder:validation:Required
	Enable *bool `json:"enable" tf:"enable,omitempty"`

	// Instance id of the APM.
	// +kubebuilder:validation:Optional
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	// Region.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ConfigObservation struct {
}

type ConfigParameters struct {

	// Sidecar inject configuration.
	// +kubebuilder:validation:Optional
	Inject []InjectParameters `json:"inject,omitempty" tf:"inject,omitempty"`

	// Istio configuration.
	// +kubebuilder:validation:Optional
	Istio []IstioParameters `json:"istio,omitempty" tf:"istio,omitempty"`

	// Prometheus configuration.
	// +kubebuilder:validation:Optional
	Prometheus []PrometheusParameters `json:"prometheus,omitempty" tf:"prometheus,omitempty"`

	// Default sidecar requests and limits.
	// +kubebuilder:validation:Optional
	SidecarResources []SidecarResourcesParameters `json:"sidecarResources,omitempty" tf:"sidecar_resources,omitempty"`

	// Tracing config.
	// +kubebuilder:validation:Optional
	Tracing []ConfigTracingParameters `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type ConfigTracingObservation struct {
}

type ConfigTracingParameters struct {

	// APM config.
	// +kubebuilder:validation:Optional
	Apm []TracingApmParameters `json:"apm,omitempty" tf:"apm,omitempty"`

	// Whether enable tracing.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Tracing sampling, 0.0-1.0.
	// +kubebuilder:validation:Optional
	Sampling *float64 `json:"sampling,omitempty" tf:"sampling,omitempty"`

	// Third party zipkin config.
	// +kubebuilder:validation:Optional
	Zipkin []TracingZipkinParameters `json:"zipkin,omitempty" tf:"zipkin,omitempty"`
}

type CustomPromObservation struct {
}

type CustomPromParameters struct {

	// Authentication type of the prometheus.
	// +kubebuilder:validation:Required
	AuthType *string `json:"authType" tf:"auth_type,omitempty"`

	// Whether it is public address, default false.
	// +kubebuilder:validation:Optional
	IsPublicAddr *bool `json:"isPublicAddr,omitempty" tf:"is_public_addr,omitempty"`

	// Password of the prometheus, used in basic authentication type.
	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password,omitempty"`

	// Url of the prometheus.
	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`

	// Username of the prometheus, used in basic authentication type.
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`

	// Vpc id.
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type InjectObservation struct {
}

type InjectParameters struct {

	// IP ranges that should not be proxied.
	// +kubebuilder:validation:Optional
	ExcludeIPRanges []*string `json:"excludeIpRanges,omitempty" tf:"exclude_ip_ranges,omitempty"`

	// Let istio-proxy(sidecar) start first, before app container.
	// +kubebuilder:validation:Optional
	HoldApplicationUntilProxyStarts *bool `json:"holdApplicationUntilProxyStarts,omitempty" tf:"hold_application_until_proxy_starts,omitempty"`

	// Let istio-proxy(sidecar) stop last, after app container.
	// +kubebuilder:validation:Optional
	HoldProxyUntilApplicationEnds *bool `json:"holdProxyUntilApplicationEnds,omitempty" tf:"hold_proxy_until_application_ends,omitempty"`
}

type IstioObservation struct {
}

type IstioParameters struct {

	// Disable http retry.
	// +kubebuilder:validation:Optional
	DisableHTTPRetry *bool `json:"disableHttpRetry,omitempty" tf:"disable_http_retry,omitempty"`

	// Disable policy checks.
	// +kubebuilder:validation:Optional
	DisablePolicyChecks *bool `json:"disablePolicyChecks,omitempty" tf:"disable_policy_checks,omitempty"`

	// Enable HTTP/1.0 support.
	// +kubebuilder:validation:Optional
	EnablePilotHTTP *bool `json:"enablePilotHttp,omitempty" tf:"enable_pilot_http,omitempty"`

	// Outbound traffic policy, REGISTRY_ONLY or ALLOW_ANY, see https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode.
	// +kubebuilder:validation:Required
	OutboundTrafficPolicy *string `json:"outboundTrafficPolicy" tf:"outbound_traffic_policy,omitempty"`

	// SmartDNS configuration.
	// +kubebuilder:validation:Optional
	SmartDNS []SmartDNSParameters `json:"smartDns,omitempty" tf:"smart_dns,omitempty"`

	// Tracing config(Deprecated, please use MeshConfig.Tracing for configuration).
	// +kubebuilder:validation:Optional
	Tracing []TracingParameters `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type LimitsObservation struct {
}

type LimitsParameters struct {

	// Resource type name, `cpu/memory`.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Resource quantity, example: cpu-`100m`, memory-`1Gi`.
	// +kubebuilder:validation:Optional
	Quantity *string `json:"quantity,omitempty" tf:"quantity,omitempty"`
}

type MeshObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MeshParameters struct {

	// Mesh configuration.
	// +kubebuilder:validation:Required
	Config []ConfigParameters `json:"config" tf:"config,omitempty"`

	// Mesh name.
	// +kubebuilder:validation:Required
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// Mesh ID.
	// +kubebuilder:validation:Optional
	MeshID *string `json:"meshId,omitempty" tf:"mesh_id,omitempty"`

	// Mesh version.
	// +kubebuilder:validation:Required
	MeshVersion *string `json:"meshVersion" tf:"mesh_version,omitempty"`

	// A list of associated tags.
	// +kubebuilder:validation:Optional
	TagList []TagListParameters `json:"tagList,omitempty" tf:"tag_list,omitempty"`

	// Mesh type.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type PrometheusObservation struct {
}

type PrometheusParameters struct {

	// Custom prometheus.
	// +kubebuilder:validation:Optional
	CustomProm []CustomPromParameters `json:"customProm,omitempty" tf:"custom_prom,omitempty"`

	// Instance id.
	// +kubebuilder:validation:Optional
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	// Region.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Subnet id.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Vpc id.
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type RequestsObservation struct {
}

type RequestsParameters struct {

	// Resource type name, `cpu/memory`.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Resource quantity, example: cpu-`100m`, memory-`1Gi`.
	// +kubebuilder:validation:Optional
	Quantity *string `json:"quantity,omitempty" tf:"quantity,omitempty"`
}

type SidecarResourcesObservation struct {
}

type SidecarResourcesParameters struct {

	// Sidecar limits.
	// +kubebuilder:validation:Optional
	Limits []LimitsParameters `json:"limits,omitempty" tf:"limits,omitempty"`

	// Sidecar requests.
	// +kubebuilder:validation:Optional
	Requests []RequestsParameters `json:"requests,omitempty" tf:"requests,omitempty"`
}

type SmartDNSObservation struct {
}

type SmartDNSParameters struct {

	// Enable auto allocate address.
	// +kubebuilder:validation:Optional
	IstioMetaDNSAutoAllocate *bool `json:"istioMetaDnsAutoAllocate,omitempty" tf:"istio_meta_dns_auto_allocate,omitempty"`

	// Enable dns proxy.
	// +kubebuilder:validation:Optional
	IstioMetaDNSCapture *bool `json:"istioMetaDnsCapture,omitempty" tf:"istio_meta_dns_capture,omitempty"`
}

type TagListObservation struct {
}

type TagListParameters struct {

	// Tag key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Passthrough to other related product.
	// +kubebuilder:validation:Optional
	Passthrough *bool `json:"passthrough,omitempty" tf:"passthrough,omitempty"`

	// Tag value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TracingApmObservation struct {
}

type TracingApmParameters struct {

	// Whether enable APM.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Instance id of the APM.
	// +kubebuilder:validation:Optional
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	// Region.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type TracingObservation struct {
}

type TracingParameters struct {

	// APM config.
	// +kubebuilder:validation:Optional
	Apm []ApmParameters `json:"apm,omitempty" tf:"apm,omitempty"`

	// Whether enable tracing.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Tracing sampling, 0.0-1.0.
	// +kubebuilder:validation:Optional
	Sampling *float64 `json:"sampling,omitempty" tf:"sampling,omitempty"`

	// Third party zipkin config.
	// +kubebuilder:validation:Optional
	Zipkin []ZipkinParameters `json:"zipkin,omitempty" tf:"zipkin,omitempty"`
}

type TracingZipkinObservation struct {
}

type TracingZipkinParameters struct {

	// Zipkin address.
	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`
}

type ZipkinObservation struct {
}

type ZipkinParameters struct {

	// Zipkin address.
	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`
}

// MeshSpec defines the desired state of Mesh
type MeshSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MeshParameters `json:"forProvider"`
}

// MeshStatus defines the observed state of Mesh.
type MeshStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MeshObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Mesh is the Schema for the Meshs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Mesh struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MeshSpec   `json:"spec"`
	Status            MeshStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MeshList contains a list of Meshs
type MeshList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Mesh `json:"items"`
}

// Repository type metadata.
var (
	Mesh_Kind             = "Mesh"
	Mesh_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Mesh_Kind}.String()
	Mesh_KindAPIVersion   = Mesh_Kind + "." + CRDGroupVersion.String()
	Mesh_GroupVersionKind = CRDGroupVersion.WithKind(Mesh_Kind)
)

func init() {
	SchemeBuilder.Register(&Mesh{}, &MeshList{})
}
