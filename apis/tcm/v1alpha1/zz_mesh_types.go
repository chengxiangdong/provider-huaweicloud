/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApmObservation struct {
}

type ApmParameters struct {

	// Whether enable APM.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Instance id of the APM.
	// +kubebuilder:validation:Optional
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	// Region.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type ConfigObservation struct {
}

type ConfigParameters struct {

	// Istio configuration.
	// +kubebuilder:validation:Optional
	Istio []IstioParameters `json:"istio,omitempty" tf:"istio,omitempty"`

	// Prometheus configuration.
	// +kubebuilder:validation:Optional
	Prometheus []PrometheusParameters `json:"prometheus,omitempty" tf:"prometheus,omitempty"`

	// Tracing config.
	// +kubebuilder:validation:Optional
	Tracing []TracingParameters `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type CustomPromObservation struct {
}

type CustomPromParameters struct {

	// Authentication type of the prometheus.
	// +kubebuilder:validation:Required
	AuthType *string `json:"authType" tf:"auth_type,omitempty"`

	// Whether it is public address, default false.
	// +kubebuilder:validation:Optional
	IsPublicAddr *bool `json:"isPublicAddr,omitempty" tf:"is_public_addr,omitempty"`

	// Password of the prometheus, used in basic authentication type.
	// +kubebuilder:validation:Optional
	Password *string `json:"password,omitempty" tf:"password,omitempty"`

	// Url of the prometheus.
	// +kubebuilder:validation:Required
	URL *string `json:"url" tf:"url,omitempty"`

	// Username of the prometheus, used in basic authentication type.
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`

	// Vpc id.
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type IstioObservation struct {
}

type IstioParameters struct {

	// Disable http retry.
	// +kubebuilder:validation:Optional
	DisableHTTPRetry *bool `json:"disableHttpRetry,omitempty" tf:"disable_http_retry,omitempty"`

	// Disable policy checks.
	// +kubebuilder:validation:Optional
	DisablePolicyChecks *bool `json:"disablePolicyChecks,omitempty" tf:"disable_policy_checks,omitempty"`

	// Enable HTTP/1.0 support.
	// +kubebuilder:validation:Optional
	EnablePilotHTTP *bool `json:"enablePilotHttp,omitempty" tf:"enable_pilot_http,omitempty"`

	// Outbound traffic policy.
	// +kubebuilder:validation:Required
	OutboundTrafficPolicy *string `json:"outboundTrafficPolicy" tf:"outbound_traffic_policy,omitempty"`

	// SmartDNS configuration.
	// +kubebuilder:validation:Optional
	SmartDNS []SmartDNSParameters `json:"smartDns,omitempty" tf:"smart_dns,omitempty"`
}

type MeshObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MeshParameters struct {

	// Mesh configuration.
	// +kubebuilder:validation:Required
	Config []ConfigParameters `json:"config" tf:"config,omitempty"`

	// Mesh name.
	// +kubebuilder:validation:Required
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// Mesh ID.
	// +kubebuilder:validation:Optional
	MeshID *string `json:"meshId,omitempty" tf:"mesh_id,omitempty"`

	// Mesh version.
	// +kubebuilder:validation:Required
	MeshVersion *string `json:"meshVersion" tf:"mesh_version,omitempty"`

	// A list of associated tags.
	// +kubebuilder:validation:Optional
	TagList []TagListParameters `json:"tagList,omitempty" tf:"tag_list,omitempty"`

	// Mesh type.
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type PrometheusObservation struct {
}

type PrometheusParameters struct {

	// Custom prometheus.
	// +kubebuilder:validation:Optional
	CustomProm []CustomPromParameters `json:"customProm,omitempty" tf:"custom_prom,omitempty"`

	// Instance id.
	// +kubebuilder:validation:Optional
	InstanceID *string `json:"instanceId,omitempty" tf:"instance_id,omitempty"`

	// Region.
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// Subnet id.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// Vpc id.
	// +kubebuilder:validation:Optional
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type SmartDNSObservation struct {
}

type SmartDNSParameters struct {

	// Enable auto allocate address.
	// +kubebuilder:validation:Optional
	IstioMetaDNSAutoAllocate *bool `json:"istioMetaDnsAutoAllocate,omitempty" tf:"istio_meta_dns_auto_allocate,omitempty"`

	// Enable dns proxy.
	// +kubebuilder:validation:Optional
	IstioMetaDNSCapture *bool `json:"istioMetaDnsCapture,omitempty" tf:"istio_meta_dns_capture,omitempty"`
}

type TagListObservation struct {
}

type TagListParameters struct {

	// Tag key.
	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// Passthrough to other related product.
	// +kubebuilder:validation:Optional
	Passthrough *bool `json:"passthrough,omitempty" tf:"passthrough,omitempty"`

	// Tag value.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type TracingObservation struct {
}

type TracingParameters struct {

	// APM config.
	// +kubebuilder:validation:Optional
	Apm []ApmParameters `json:"apm,omitempty" tf:"apm,omitempty"`

	// Whether enable tracing.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Tracing sampling, 0.0-1.0.
	// +kubebuilder:validation:Optional
	Sampling *float64 `json:"sampling,omitempty" tf:"sampling,omitempty"`

	// Third party zipkin config.
	// +kubebuilder:validation:Optional
	Zipkin []ZipkinParameters `json:"zipkin,omitempty" tf:"zipkin,omitempty"`
}

type ZipkinObservation struct {
}

type ZipkinParameters struct {

	// Zipkin address.
	// +kubebuilder:validation:Required
	Address *string `json:"address" tf:"address,omitempty"`
}

// MeshSpec defines the desired state of Mesh
type MeshSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MeshParameters `json:"forProvider"`
}

// MeshStatus defines the observed state of Mesh.
type MeshStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MeshObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Mesh is the Schema for the Meshs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tencentcloudjet}
type Mesh struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MeshSpec   `json:"spec"`
	Status            MeshStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MeshList contains a list of Meshs
type MeshList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Mesh `json:"items"`
}

// Repository type metadata.
var (
	Mesh_Kind             = "Mesh"
	Mesh_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Mesh_Kind}.String()
	Mesh_KindAPIVersion   = Mesh_Kind + "." + CRDGroupVersion.String()
	Mesh_GroupVersionKind = CRDGroupVersion.WithKind(Mesh_Kind)
)

func init() {
	SchemeBuilder.Register(&Mesh{}, &MeshList{})
}
